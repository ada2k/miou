<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>scheduler (miou.scheduler)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">miou</a> &#x00BB; scheduler</nav><header class="odoc-preamble"><h2 id="a-simple-scheduler-with-ocaml-5."><a href="#a-simple-scheduler-with-ocaml-5." class="anchor"></a>A simple scheduler with OCaml 5.</h2><p>This short tutorial shows you how to create a simple scheduler in OCaml with effects. We'd like to warn the reader that certain choices have been made to suit our purposes: in other words, as opposed to Tatcher, there <b>are</b> alternatives in implementing a scheduler. This tutorial is not <i>absolutist</i> in what it explains.</p><p>We therefore advise our readers to take a critical look at what we present.</p><p>A scheduler can be seen as a program that attempts to run another program (just as your system attempts to run your software). Thus, there is an interaction between the program to be executed and the scheduler: basically, the creation and awaiting of tasks.</p><p>With the advent of effects in OCaml, we now have the ability to &quot;suspend&quot; a function. In other words, we can have a state (which we can manipulate) that corresponds to a function that has not yet finished. When it comes to implementing a scheduler, it may be useful to keep this suspension in order to prioritize the execution of other suspended functions.</p><p>In other words, we schedule the execution of these functions.</p></header><nav class="odoc-toc"><ul><li><a href="#effects.">Effects.</a><ul><li><a href="#suspension.">Suspension.</a></li><li><a href="#shallow-&amp;-deep.">Shallow &amp; Deep.</a></li></ul></li><li><a href="#a-task.">A task.</a></li><li><a href="#a-promise.">A promise.</a></li><li><a href="#the-scheduler.">The scheduler.</a></li><li><a href="#the-result!">The result!</a></li><li><a href="#conclusion.">Conclusion.</a></li></ul></nav><div class="odoc-content"><h3 id="effects."><a href="#effects." class="anchor"></a>Effects.</h3><p>The simplest explanation of what an effect is, based on known OCaml elements, is the exception. The exception, in OCaml, allows you to break the execution flow and &quot;fall&quot; into an exception handler.</p><pre class="language-ocaml"><code>exception World

let my_function () =
  print_endline &quot;Hello&quot;;
  raise World
  
let my_program () =
  try my_function ()
  with World -&gt;
    print_endline &quot;World&quot;</code></pre><p>So there are 3 elements to identify:</p><ol><li>exception definition (<code>exception</code>)</li><li>raising the exception (<code>raise</code>)</li><li>installing an exception handler (with <code>try ... with ...</code>)</li></ol><p>Effects do the same thing. An effects handler exists, and if the user &quot;performs&quot; an effect, the execution flow is broken in order to &quot;fall&quot; into the handler.</p><pre class="language-ocaml"><code>open Effect.Shallow

type _ Effect.t += World : unit Effect.t

let handler =
  let retc x = x
  and exnc = raise
  and effc
    : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'a) option
    = function
    | World -&gt;
      print_endline &quot;World&quot;;
      Some (fun k -&gt; continue k ())
    | _ -&gt; None in
  { retc; exnc; effc; }

let my_function () =
  print_endline &quot;Hello&quot;;
  Effect.perform World

let my_program () =
  match_with my_function () handler</code></pre><p>It does, however, add an extra element to the effects. As far as exceptions are concerned, we can't go back to the place where the exception was raised. For effects, on the other hand, we are given a &quot;continuation&quot; (our <code>k</code> value) which allows us to continue immediately after the effect has been raised.</p><p>For the example, this code would have no equivalence with exceptions, as we want to continue.</p><pre class="language-ocaml"><code>open Effect.Shallow

type _ Effect.t += Hello : unit Effect.t

let handler =
  let retc x = x
  and exnc = raise
  and effc
    : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'a) option
    = function
    | Hello -&gt;
      print_endline &quot;Hello&quot;;
      Some (fun k -&gt; continue k ())
    | _ -&gt; None in
  { retc; exnc; effc; }

let my_function () =
  Effect.perform Hello;
  print_endline &quot;World&quot;

let my_program () =
  match_with my_function () handler</code></pre><h4 id="suspension."><a href="#suspension." class="anchor"></a>Suspension.</h4><p>The most important thing to understand in terms of effects is <b>suspension</b>. After an effect has been performed, OCaml gives us a value that corresponds to a suspended state of the function that performed the effect.</p><p>From this value, we can:</p><ul><li>continue as in the example</li><li>discontinue with an exception</li></ul><p>But what can become interesting in the context of a scheduler is to <b>keep</b> this suspension! We could consider that the effect should produce a result, but that this result is not yet available. In this case, it would be:</p><ol><li>keep our suspension</li><li>give other functions the opportunity to run (and help us get our first result)</li><li>&quot;continue&quot; our suspension afterwards if we have obtained the expected result after our rescheduling.</li></ol><h4 id="shallow-&amp;-deep."><a href="#shallow-&amp;-deep." class="anchor"></a>Shallow &amp; Deep.</h4><p>There's one final detail to note about the effects. The existence of 2 modules: Deep &amp; Shallow. At this stage, and with the aim of implementing a simple scheduler, the choice of one or the other is not very interesting. However, we must clarify the difference.</p><p>The difference lies in how the handler is installed. In the case of Shallow, installation allows you to manage a single effect. Once you've managed it, you'll need to re-install a handler. In a way, this constraint &quot;forces&quot; you not to continue directly with a suspension (which could launch a new effect!) but to have an intermediate suspension handling step in which you could (and should) re-install a handler.</p><p>In Deep's case, a single installation is sufficient. The function could launch several effects, but these would always be overtaken by the initially installed handler. This makes it possible to &quot;just continue&quot; for certain &quot;basic&quot; effects, without really worrying about the suspension and how it's continued - you'll still be using the same handler.</p><p>For the purposes of this tutorial, we prefer to use Shallow. These constraints allow us to dissociate the suspension from the operation associated with the effect that produced the suspension.</p><h3 id="a-task."><a href="#a-task." class="anchor"></a>A task.</h3><p>As we mentioned earlier, a task (which our scheduler should handle) is the smallest sequence of programmed instructions: it's an OCaml function.</p><p>Now we need to define a state for this function:</p><ol><li>The function hasn't run yet, but it should</li><li>The function has finished and we have its result</li><li>The function has been suspended at a point (by an effect) that can be continued.</li></ol><pre class="language-ocaml"><code>type 'a t =
  | Launch : (unit -&gt; 'a) -&gt; 'a t
  | Finished of 'a
  | Suspended : ('a, 'b) Effect.Shallow.continuation * 'a Effect.t -&gt; 'b t</code></pre><p>Now we need to describe our effect handler, which should produce this state. It's actually quite simple, as it only involves producing the final state (the function has terminated) or the suspended state. The <code>Launch</code> state will be created by a &quot;spawn&quot; function.</p><pre class="language-ocaml"><code>let handler =
  let open Effect.Shallow in
  let retc v = Finished v in
  let exnc = raise in
  let effc
    : type c. c Effect.t -&gt; ((c, 'a) Effect.Shallow.continuation -&gt; 'b) option
    = fun effect -&gt; Some (fun k -&gt; Suspended (k, effect)) in
  { Effect.Shallow.retc; exnc; effc }</code></pre><p>All we have to do is install this handler systematically each time we want to <i>continue</i> with our task. Note that ALL effects are suspended. The aim is to differentiate the suspension mechanism from the handling of the effect and its associated operation.</p><h3 id="a-promise."><a href="#a-promise." class="anchor"></a>A promise.</h3><p>We still need to define a few last elements for our scheduler so that the user can interact with it:</p><ul><li>of course, there's the effect that will create a task</li><li>but also a promise as a <i>witness</i> to the task's progress</li><li>from this promise, we can have a last interation, awaiting task completion</li></ul><p>Finally, a last type allows us to manipulate tasks independently of the type of their results.</p><pre class="language-ocaml"><code>type _ Effect.t += Spawn : (unit -&gt; 'a) -&gt; 'a promise Effect.t
and 'a promise = 'a option ref
and _ Effect.t += Await : 'a promise -&gt; 'a Effect.t
and elt = Elt : 'a t -&gt; task</code></pre><p>The promise is a cell that can be updated once the task has been completed. The wait will then consist of observing this value and returning the result if available.</p><h3 id="the-scheduler."><a href="#the-scheduler." class="anchor"></a>The scheduler.</h3><p>All that remains is to implement the operations associated with our effects and to implement our <i>main loop</i>, which will consist of trying to do all our tasks until there are none left.</p><p>This gives us a to-do list that we can complete with <code>Spawn</code>. Adding a task will consist of:</p><ol><li>creating the promise</li><li>updating the promise at the end of our task</li></ol><p>Finally, <code>Await</code> will simply observe the promise, and if it hasn't yet been <i>fulfilled</i>, it will give the other tasks another chance (<i>yield</i>) to run so that, perhaps, we can resolve the promise later.</p><pre class="language-ocaml"><code>let perform
  : type c. elt list ref -&gt; c Effect.t -&gt; [ `Continue of c | `Yield ]
  = fun todo -&gt; function
  | Spawn fn -&gt;
    let value = ref None in
    let task = Launch (fun () -&gt; value := Some (fn ())) in
    todo := !todo @ [ Task task ] ;
    `Continue value
  | Await value -&gt;
    begin match !value with
    | Some value -&gt; `Continue value
    | None -&gt; `Yield end
  | _ -&gt; invalid_arg &quot;Invalid effect&quot;</code></pre><p>Finally, the main loop will simply do the tasks one after the other, step by step. These steps are defined by the production of effects. In our case, we fall back on one of Miou's rules: effect yield.</p><pre class="language-ocaml"><code>let step todo = function
  | Launch fn -&gt;
    Effect.Shallow.(continue_with (fiber fn) () handler)
  | Finished v -&gt; Finished v
  | Suspended (k, effect) -&gt;
    match perform todo effect with
    | `Continue v -&gt; Effect.Shallow.(continue_with k v handler)
    | `Yield -&gt; Suspended (k, effect)

let run fn v =
  let result = ref None in
  let rec go = function
    | [] -&gt; Option.get !result
    | Task task :: rest -&gt;
      let todo = ref rest in
      match step todo task with
      | Finished _ -&gt; go !todo
      | (Launch _ | Suspended _) as task -&gt; go (!todo @ [ Task task ]) in
  let task = Launch (fun () -&gt; result := Some (fn v)) in
  go [ Task task ]</code></pre><h3 id="the-result!"><a href="#the-result!" class="anchor"></a>The result!</h3><p>In the end, all we need to do is propose a nice API for this scheduler, consisting of 3 functions:</p><ol><li>task creation</li><li>waiting for task completion</li><li>our effects installer</li></ol><pre class="language-ocaml"><code>let spawn fn = Effet.perform (Spawn fn)
let await prm = Effet.perform (Await prm)

let my_function =
  let prm = spawn @@ fun () -&gt; print_endline &quot;Hello&quot; in
  print_endline &quot;World&quot;;
  await prm

let () = run my_function ()</code></pre><p>In this small example, it's clear that our first task didn't run directly! It was added to our todo list, but it was only the <code>Await</code> and its rescheduling that gave our first task the opportunity to run.</p><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>Admittedly, this code is quite simple and doesn't really define concepts that are important for a scheduler such as this:</p><ul><li>cancellation</li><li>system event management</li><li>parallelism</li></ul><p>It's basically a short introduction to how to make a scheduler in OCaml with effects, but it's certainly necessary to go further. Well, Miou exists!</p><p>Nevertheless, it provides a practical mental model for understanding how Miou can organize these tasks. One particular point, better documented in Miou's introduction, concerns the priority of tasks: could we prioritize the display of <code>&quot;Hello&quot;</code> in our example? To this question, Miou doesn't prioritize any tasks like this example. We simply &quot;add&quot; suspended tasks to the end of our todo list.</p></div></body></html>
