<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>echo (miou.echo)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">miou</a> &#x00BB; echo</nav><header class="odoc-preamble"><h2 id="a-simple-echo-server-with-miou."><a href="#a-simple-echo-server-with-miou." class="anchor"></a>A simple echo server with Miou.</h2><p>In this short tutorial, we'll look at how to implement a simple &quot;echo&quot; server. The idea is to manage incoming connections and &quot;repeat&quot; what the user has written. It is equivalent to this server with &quot;netcat&quot;:</p><pre class="language-ocaml"><code>$ mknod fifo p
$ cat fifo | nc -l 9000 &gt; fifo</code></pre><p>We're going to use <a href="Miou_unix/index.html"><code>Miou_unix</code></a>, which is an extension of Miou with some functions available via the <code>Unix</code> module. These functions are blocking and if you're wondering why we need a layer to implement these functions, we suggest you take a look at the tutorial on <a href="sleepers.html"><code>sleepers</code></a>.</p></header><nav class="odoc-toc"><ul><li><a href="#a-simple-sequential-server.">A simple sequential server.</a></li><li><a href="#concurrency.">Concurrency.</a><ul><li><a href="#ownership.">Ownership.</a></li></ul></li><li><a href="#background-tasks-and-miou.">Background tasks and Miou.</a></li><li><a href="#parallelism.">Parallelism.</a></li><li><a href="#conclusion.">Conclusion.</a></li></ul></nav><div class="odoc-content"><h3 id="a-simple-sequential-server."><a href="#a-simple-sequential-server." class="anchor"></a>A simple sequential server.</h3><p>Let's start at the beginning: create a function to manage our customers and another function to manage the acceptance of connections.</p><pre class="language-ocaml"><code>let handler fd =
  let buf = Bytes.create 0x100 in
  let rec go () =
    let len = Miou_unix.read fd buf ~off:0 ~len:(Bytes.length buf) in
    if len &gt; 0 then begin
      Miou_unix.write fd (Bytes.unsafe_to_string buf) ~off:0 ~len;
      go ()
    end else Miou_unix.close fd in
  go

let listen sockaddr =
  let fd = Miou_unix.tcpv4 () in
  Miou_unix.bind_and_listen fd sockaddr; fd

let server sockaddr =
  let rec server fd =
    let fd', sockaddr = Miou_unix.accept fd in
    handler fd' ();
    server fd in
  fun () -&gt; server (listen sockaddr)

let addr = Unix.ADDR_INET (Unix.inet_addr_loopback, 9000)
let () = Miou_unix.run (server addr) </code></pre><p>This small program provides a systematic structure for implementing a server:</p><ol><li>a loop that accepts TCP/IP connections</li><li>a handler which manages a connection</li></ol><h3 id="concurrency."><a href="#concurrency." class="anchor"></a>Concurrency.</h3><p>The main problem with this implementation is that you can only manage one connection, so it can terminate and then wait for and receive a new connection. In other words, our server only manages one client.</p><p>The way to manage several clients is to create <b>asynchronous</b> tasks. The aim of asynchronous tasks is to run concurrently without one blocking the others. If a task appears to be blocking, it will be suspended and the scheduler will try to execute another one.</p><p>In our case, our <code>handler</code> is blocking on the <a href="Miou_unix/index.html#val-read"><code>Miou_unix.read</code></a> operation. So we're going to give Miou the ability to suspend our <code>handler</code> in order to check whether <a href="Miou_unix/index.html#val-accept"><code>Miou_unix.accept</code></a> is also waiting or whether a connection has just arrived.</p><p>To specify an asynchronous task with Miou, we use <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a>:</p><pre class="language-ocaml"><code>let server sockaddr =
  let rec server prms fd =
    let fd', sockaddr = Miou_unix.accept fd in
    let prm = Miou.call_cc ~give:[ Miou_unix.owner fd' ] (handler fd') in
    Miou_unix.disown fd';
    server (prm :: prms) fd in
  fun () -&gt; server [] (listen sockaddr)</code></pre><p>Using <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> returns a &quot;promise&quot;. It's a kind of <i>witness</i> for our task that lets us know the status of it:</p><ul><li>whether it is running</li><li>whether it has finished successfully</li><li>if it has stopped abnormally (by raising an exception)</li></ul><p>It is possible to manipulate this promise and wait for our task to finish:</p><pre class="language-ocaml"><code>let server sockaddr =
  let rec server fd =
    let fd', sockaddr = Miou_unix.accept fd in
    let prm = Miou.call_cc ~give:[ Miou_unix.owner fd' ] (handler fd') in
    Miou_unix.disown fd';
    ignore (Miou.await_exn prm);
    server fd in
  fun () -&gt; server (listen sockaddr)</code></pre><p>The problem with the code above is that we're back to the same behaviour we started with. Namely, waiting for our <code>handler</code> to finish before managing a new connection (and therefore only managing one client at a time).</p><h4 id="ownership."><a href="#ownership." class="anchor"></a>Ownership.</h4><p>Miou has a mechanism for 'attaching' resources to a task. The aim of this mechanism is to bind the use of a resource to a function - a bit like Rust, but in a <i>dynamic</i> way. Operations such as <a href="Miou_unix/index.html#val-read"><code>Miou_unix.read</code></a> or <a href="Miou_unix/index.html#val-write"><code>Miou_unix.write</code></a> will check that the function has the given file-descriptor - if not, a <code>Not_owner</code> exception is thrown.</p><p>In our case, <a href="Miou_unix/index.html#val-accept"><code>Miou_unix.accept</code></a> <i>creates</i> the file-descriptor, so it belongs to our <code>server</code> function. We therefore need to pass the ownership to our task <code>handler</code> via the <code>give</code> argument.</p><p>Ownership is mainly used to &quot;finalise&quot; a resource in an abnormal case. As a developer, we have a duty to release all our resources (even in abnormal cases). So, if our <code>handler</code> function raises an exception, Miou will take care of closing our associated file-descritptor.</p><h3 id="background-tasks-and-miou."><a href="#background-tasks-and-miou." class="anchor"></a>Background tasks and Miou.</h3><p>Miou enforce good practice and one of them is to always take care of these promises. In this case, we'd like to both keep our promise and launch others concurrently.</p><p>One possibility available in other schedulers is to <i>detach</i> a task. Promises allow you to keep <i>a link</i> with a task (since they are a witness to tasks). But if we can &quot;forget&quot; a promise and therefore let a task run without it being linked, we could solve our initial problem.</p><p>The next problem with such an approach is that we also forget the resources associated with the task (particularly the <a href="Miou_unix/index.html#type-file_descr"><code>Miou_unix.file_descr</code></a>s), and these resources should be freed (<a href="Miou_unix/index.html#val-close"><code>Miou_unix.close</code></a>) up in any case (specially the abnormal case when we trigger an exception). So you end up having to manage the termination of a task (and the release of resources) while at the same time trying to forget about the task. But initially, the simple fact of wanting to detach a task <b>is</b> a leakage of resources.</p><p>Miou proposes another mechanism, which is to keep our promises somewhere and 'clean up' the ones that have finished. So we're going to introduce the use of an <a href="Miou/index.html#type-orphans"><code>Miou.orphans</code></a> value.</p><pre class="language-ocaml"><code>let rec clean_up orphans = match Miou.care orphans with
  | Some (Some prm) -&gt; Miou.await_exn prm; clean_up orphans
  | Some None -&gt; ()
  | None -&gt; ()

let server sockaddr =
  let rec server orphans fd =
    clean_up orphans;
    let fd', sockaddr = Miou_unix.accept fd in
    let _ = Miou.call_cc
      ~give:[ Miou_unix.owner fd' ] ~orphans (handler fd') in
    Miou_unix.disown fd';
    server orphans fd in
  fun () -&gt;
    server (Miou.orphans ()) (listen sockaddr)</code></pre><p>The orphans value will aggregate the promises (which are the children of the <code>server</code> task) which then become <i>orphans</i>.</p><p>The advantage then resides in the <a href="Miou/index.html#val-care"><code>Miou.care</code></a> function, which will return an orphan ready to be waited for. In this case, using <a href="Miou/index.html#val-await"><code>Miou.await</code></a> on this orphan will <b>not</b> block. <i>The orphans are cleaned up.</i> This operation is repeated each time a TCP/IP connection is received. In this way, we avoid detaching our tasks and we can take a real interest in how our tasks ended (in our case, we ignore the result).</p><p>It can be annoying to have to manage promises systematically (and not be able to forget them). However, apart from the fact that it is illegal to forget one's children, detachment involves checks on the part of the developer which, if forgotten, can lead to a memory leak. Indeed, even if you could forget a task, the scheduler doesn't!</p><p>From our experience and from using and implementing large software packages, this is perhaps one of the anti-patterns that we have found most frequently and that still causes problems.</p><h3 id="parallelism."><a href="#parallelism." class="anchor"></a>Parallelism.</h3><p>One of the big advantages of Miou is that it is easy to consider the parallelization of a task. In this case, <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> can easily be replaced by <a href="Miou/index.html#val-call"><code>Miou.call</code></a>.</p><pre class="language-ocaml"><code>let server sockaddr =
  let rec server orphans fd =
    clean_up orphans;
    let fd', sockaddr = Miou_unix.accept fd in
    let _ = Miou.call_cc
      ~give:[ Miou_unix.owner fd' ] ~orphans (handler fd') in
    Miou_unix.disown fd';
    server orphans fd in
  fun () -&gt;
    server (Miou.orphans ()) (listen sockaddr)</code></pre><p>However, there is a bottleneck. In this case, our <code>dom0</code> is the only one to manage the server task. In other words: a single domain manages the reception of connections.</p><p>Once again, Miou is interested in the development of system and network applications where <b>the availability</b> of the application to receive events from the system is essential. We could imagine that instead of having a single domain that manages the reception of connections, we could have several?</p><pre class="language-ocaml"><code>let server sockaddr =
  let rec server orphans fd =
    clean_up orphans;
    let fd', sockaddr = Miou_unix.accept fd in
    let _ = Miou.call_cc
      ~give:[ Miou_unix.owner fd' ] ~orphans (handler fd') in
    Miou_unix.disown fd';
    server orphans fd in
  fun () -&gt;
    server (Miou.orphans ()) (listen sockaddr)

let addr = Unix.ADDR_INET (Unix.inet_addr_loopback, 9000)

let () = Miou.run @@ fun () -&gt;
  let prm = Miou.call_cc (server addr) in
  Miou.parallel server
    (List.init (Miou.Domain.count ()) (Fun.const addr))
  |&gt; List.iter (function Ok () -&gt; () | Error exn -&gt; raise exn);
  Miou.await_exn prm</code></pre><p>So we've gone from 1 domain handling all the connections to several domains implementing a parallel echo server!</p><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>Developing a system and network application with Miou addresses several points:</p><ul><li>always keep an eye on resources (including tasks) so that there can be no memory leaks</li><li>provide a high level of availability in order to manage trillions of connections</li><li>Finally, take advantage of parallelism.</li></ul><p>This tutorial shows what Miou is finally proposing. However, there are a few caveats:</p><ol><li>The extension of Miou to other system events is explained in more detail in our tutorial on <a href="sleepers.html"><code>sleepers</code></a>.</li><li>We have not attempted to implement a mechanism that stops our servers. We could do it with a signal handler and <a href="Miou_unix/Cond/index.html#type-t"><code>Miou_unix.Cond.t</code></a> but we let the user choose the best way according to their expectations.</li></ol><p>We therefore recommend that you read these tutorials to learn more about Miou's design, its reasons and its implications. At the very least, we hope that this tutorial lets you imagine the possibility of implementing your service using our library.</p></div></body></html>
