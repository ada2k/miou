<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>sleepers (miou.sleepers)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">miou</a> &#x00BB; sleepers</nav><header class="odoc-preamble"><h2 id="sleepers:-how-to-inject-syscalls-into-miou?"><a href="#sleepers:-how-to-inject-syscalls-into-miou?" class="anchor"></a>Sleepers: how to inject syscalls into <code>miou</code>?</h2><p>This tutorial shows how to inject a new syscall to <code>miou</code> and extend the API of it with <i>blocking</i> operations. For the example, we're going to implement the sleepers. <code>Unix.sleepf</code> is a blocking operation. The fundamental problem with <code>miou</code> is that it performs operations in the background (scheduling). So using a blocking operation with <code>miou</code> prevents it from managing other tasks concurrently (manage tasks entered with <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a>) or in parallel (wait for parallel process tasks introduced by <a href="Miou/index.html#val-call"><code>Miou.call</code></a>).</p><p>As stated in the documentation, and this is a fundamental rule: &gt; you should never give <code>miou</code> blocking tasks (such as <code>Unix.sleepf</code>)</p><p>That said, how do you manage blocking tasks? <code>miou</code> offers an API that allows you to extend its API with such tasks. The idea is to inform <code>miou</code> of a promise that is <b>not</b> associated with a task (because the latter would be blocking) and to notify it of the task that we would like to do as soon as we are <b>sure</b> that it is a non-blocking task.</p><p>This notification is possible because <code>miou</code> lets you inject such a function which will notify it. This is the <code>events</code> function expected as a parameter to the <a href="Miou/index.html#val-run"><code>Miou.run</code></a> function.</p></header><nav class="odoc-toc"><ul><li><a href="#what-we-want-to-do?">What we want to do?</a></li><li><a href="#syscalls.">Syscalls.</a></li><li><a href="#usage.">Usage.</a></li><li><a href="#the-reason-behind-this-api.">The reason behind this API.</a></li><li><a href="#events-&amp;-domains.">Events &amp; domains.</a><ul><li><a href="#local-events-at-domains-and-local-storage.">Local events at domains and local storage.</a></li><li><a href="#cancellation-&amp;-interruption.">Cancellation &amp; interruption.</a></li></ul></li><li><a href="#conclusion.">Conclusion.</a></li></ul></nav><div class="odoc-content"><h3 id="what-we-want-to-do?"><a href="#what-we-want-to-do?" class="anchor"></a>What we want to do?</h3><p>So let's get down to business. The aim of this tutorial is to enable you to write this code:</p><pre class="language-ocaml"><code>open Miou

let program () =
  Miou.run @@ fun () -&gt;
  let a = Miou.call_cc (fun () -&gt; sleep 1.) in
  let b = Miou.call_cc (fun () -&gt; sleep 2.) in
  Miou.await_all [ a; b ]
  |&gt; List.iter @@ function Ok () -&gt; () | Error exn -&gt; raise exn

let () =
  let t0 = Unix.gettimeofday () in
  program ();
  let t1 = Unix.gettimeofday () in
  assert (t1 -. t0 &lt; 3.)</code></pre><p>This code explains simple behaviour: our tasks <code>a</code> and <code>b</code> should run concurrently. In other words, in the end, we should consume strictly less than 3 seconds (about 2 seconds) to complete this little program.</p><p>You can have fun replacing <code>sleep</code> with <code>Unix.sleepf</code> and you'll see that we're back to a simple sequential execution where we need 3 seconds to finish the program. And that's normal, <code>miou</code> doesn't know that <code>Unix.sleepf</code> is blocking, so it will execute the two tasks one after the other without scheduling them correctly.</p><p>So we've got our test, which will validate what we're expecting.</p><h3 id="syscalls."><a href="#syscalls." class="anchor"></a>Syscalls.</h3><p>The <a href="Miou/index.html"><code>Miou</code></a> module is fairly straightforward about what can (and cannot) be done about <i>promises</i> not associated with a task. You can create such a promise (<a href="Miou/index.html#val-make"><code>Miou.make</code></a>), <b>suspend</b> and wait for its result <a href="Miou/index.html#val-suspend"><code>Miou.suspend</code></a>) and obtain its unique identifier (<a href="Miou/index.html#val-uid"><code>Miou.uid</code></a>). And that's it!</p><p>The first function allows us to create our <code>sleep</code> &quot;syscall&quot;. The second will allow us to specify the point at which we would like to obtain the result of our blocking operation and the third function will allow us to <b>keep</b> (and <b>store</b>) this <i>promise</i> so that we can find it again later.</p><pre class="language-ocaml"><code>open Miou

let sleepers = Hashtbl.create 0x100

let sleep until =
  let return () = () in
  let promise = Miou.make return in
  Hashtbl.add sleepers (Miou.uid promise) (promise, until);
  match Miou.suspend promise with Ok () -&gt; () | Error exn -&gt; raise exn</code></pre><p>As you can see, the implementation of a 'syscall' is relatively simple, but it is always associated with the implementation or extension of another function: the <code>events</code> function. The <code>return</code> value is the function that is called as soon as the promise <b>is</b> resolved. In our case, we would like to return <code>() : unit</code> but we could very well return the value of a reference that the task of resolving our promise will modify correctly.</p><p><code>miou</code> is quite stupid, trying to carry out all the tasks we give it in the hope that they will solve our promises. And it does this as long as it has at least one unresolved promise. In our case, the promise we've just created will never be resolved by any task. To clarify <code>miou</code>'s behaviour in this situation, you can run this code:</p><pre class="language-ocaml"><code>let dummy _ =
  { select= Fun.const []
  ; interrupt= ignore }

let () = Miou.(run ~events:dummy @@ fun () -&gt; sleep 1.; ())</code></pre><p>This code will never end simply because a promise is always waiting to be solved.</p><p>But as you can see, I've specified an <code>events</code> function here which always returns an empty list. In truth, if <code>miou</code> has no more tasks to do and there are still promises, it will try one last thing: execute our <code>events</code> function. This can return a new task (always non-blocking) that could resolve a given promise. And it's here that we'll be able to inject the tasks that will resolve our sleepers.</p><p>Contrary to what we have just said, this <code>events</code> function (and only this one) <b>can block</b>! And, in reality, this is not a problem as all the tasks have been executed. We can therefore be in a <i>busy waiting</i> state for the next event to unblock our execution flow.</p><p>In our case, it's a case of taking the <b>smallest</b> sleeper, waiting and then returning a task that resolves that same sleeper. We also need to update the other sleepers because we're going to consume time.</p><pre class="language-ocaml"><code>let select () =
  let min =
    Hashtbl.fold
      (fun uid (prm, until) -&gt; function
        | Some (_uid', _prm', until') when until &lt; until' -&gt;
            Some (uid, prm, until)
        | Some _ as acc -&gt; acc
        | None -&gt; Some (uid, prm, until))
      sleepers None
  in
  match min with
  | None -&gt; []
  | Some (uid, prm, until) -&gt;
      Hashtbl.remove sleepers uid;
      Hashtbl.filter_map_inplace
        (fun _ (prm, until') -&gt; Some (prm, Float.max 0. (until' -. until)))
        sleepers;
      Unix.sleepf until;
      [ Miou.task prm (Fun.const ()) ]

let events _ = { select; interrupt= ignore }</code></pre><h3 id="usage."><a href="#usage." class="anchor"></a>Usage.</h3><p>Now that we have our <code>events</code> function and our <i>syscall</i> <code>sleep</code>, we can use them:</p><pre class="language-ocaml"><code>let prgm () =
  Miou.run ~events @@ fun () -&gt;
  let a = Miou.call_cc (fun () -&gt; sleep 1.) in
  let b = Miou.call_cc (fun () -&gt; sleep 2.) in
  ignore (Miou.await a);
  ignore (Miou.await b)

let () =
  let t0 = Unix.gettimeofday () in
  prgm ();
  let t1 = Unix.gettimeofday () in
  assert (t1 -. t0 &lt; 3.)</code></pre><p>Note that our <code>events</code> function has been transferred to <a href="Miou/index.html#val-run"><code>Miou.run</code></a>! Without it, our code wouldn't work. And that's it! Our program did not fail to run, which means that we used <b>less</b> than 3 seconds (about 2).</p><pre class="language-ocaml"><code>$ ocamlfind opt -linkpkg -package miou main.ml
$ ./a.out
$ echo $?
0</code></pre><p>And now we have proof that our 2 processes ran &quot;at the same time&quot;. We say that they ran cooperatively. Sleepers are a good example for understanding the syscalls mechanism with <code>miou</code>, but of course you can extend this yourself with <code>read</code>, <code>write</code> and <code>select</code> as functions notifying us of system events.</p><h3 id="the-reason-behind-this-api."><a href="#the-reason-behind-this-api." class="anchor"></a>The reason behind this API.</h3><p>The notion of &quot;injection&quot; was mentioned a few times, which consists of giving the user the possibility of implementing the syscalls they want. The main reason for this API is that it is not dependent on the <code>Unix</code> module. In fact, apart from being particularly consistent, we believe that the I/O issue is not an issue that fits into the <i>scheduling</i> problem, but is intrinsic to scheduling. In other words, we can make a library about <i>scheduling</i> that does not require and provide I/O solutions.</p><p>What's more, the I/O is actually quite subtle from one system to another. The behaviour of <code>connect()</code>, for example, bears witness to this between <b>Linux</b> and <b>*BSD</b>. This means that we have to come up with an implementation that behaves in the same way regardless of the system - as you can imagine, this is a tedious and difficult job. Above all, it's work that may have nothing to do with scheduling.</p><p>So the aim is to transfer all this complexity away from what <code>miou</code> does best: scheduling. Of course, we're not leaving the user as it is, and we're offering an extension to <code>miou</code> with the implemented I/O cleverly called <code>miouu</code> (<code>miou</code> with <code>U</code>nix).</p><h3 id="events-&amp;-domains."><a href="#events-&amp;-domains." class="anchor"></a>Events &amp; domains.</h3><p>As you can imagine, this little introduction is not complete if we take into account <a href="Miou/index.html#val-call"><code>Miou.call</code></a>. <code>miou</code> can launch tasks in parallel and these tasks can perform I/O. In our example, we can replace <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> with <a href="Miou/index.html#val-call"><code>Miou.call</code></a>. The problems that will arise from such a change will be, to say the least, difficult to explain in full. However, they focus on a point that is fairly simple to see: we are <b>not</b> protecting our <code>sleepers</code> from changes that several domains can make <i>at the same time</i>.</p><p>Overall, this often requires <i>synchronisation mechanisms</i> between domains in order to manage parallel access to our <code>sleepers</code>. However, if you have already done some parallel programming, these mechanisms can:</p><ul><li>be cumbersome and require resources such as <code>Mutex</code>, <code>Condition</code>, etc.</li><li>be error prone in very subtle cases of how domains will react.</li></ul><p>Based on these findings, we propose a fairly simple design: a <i>syscall</i> is <b>always</b> managed by the domain that launched it (it is somewhat equivalent to <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a>).</p><h4 id="local-events-at-domains-and-local-storage."><a href="#local-events-at-domains-and-local-storage." class="anchor"></a>Local events at domains and local storage.</h4><p>So, if we consider promises that can suspend the flow of execution that are always local to a domain, we can consider that each domain should have its own <code>sleepers</code> and that access to them should only be made by a single domain (the one with which they are associated).</p><p>From this idea, you can use a <i>local storage</i>. OCaml proposes that you can associate values with domains and retrieve these values according to the domain. This is done using the <code>Domain</code>.DLS module.</p><pre class="language-ocaml"><code>let sleepers =
  let make () = Hashtbl.create 0x100 in
  let key = Domain.DLS.new_key make in
  fun () -&gt; Domain.DLS.get key</code></pre><p>We then just need to call <code>sleepers ()</code> in all the places where we use our hash-table to make sure we're using the one that's local to the domain. And voilÃ ! As you can see, using <i>Domain Local Storage</i> simplifies our code enormously and saves us from having to implement and manage synchronisation mechanisms between domains.</p><h4 id="cancellation-&amp;-interruption."><a href="#cancellation-&amp;-interruption." class="anchor"></a>Cancellation &amp; interruption.</h4><p>There is, however, one final point that we have deliberately omitted from this little tutorial: interruption. It was explained above that our <code>events</code> function can block and that it's no big deal - in fact, it is. We need to rephrase this assumption: <code>events</code> can block, but there must be a way for <code>miou</code> to unblock the function - and by extension, the domain.</p><p>It's fair to ask why we would need such a mechanism. The answer is cancellation. It is possible to <a href="Miou/index.html#val-cancel"><code>Miou.cancel</code></a> a task with <code>miou</code>.</p><pre class="language-ocaml"><code>let prgm () =
  Miou.run ~events @@ fun () -&gt;
  let a = Miou.call (fun () -&gt; sleep 10.) in
  sleep 1.; Miou.cancel a;
  match Miou.await a with
  | Error Miou.Cancelled -&gt; ()
  | _ -&gt; failwith &quot;test&quot;

let () =
  let t0 = Unix.gettimeofday () in
  prgm () ;
  let t1 = Unix.gettimeofday ()  in
  assert (t1 -. t0 &lt; 10.)</code></pre><p>In this example, a domain is asked to <code>sleep</code> for 10 seconds. But, at the same time, we want to <a href="Miou/index.html#val-cancel"><code>Miou.cancel</code></a> this task. At the moment, the domain will wait 10 seconds and then be &quot;cancelled&quot;. This is where the interrupt mechanism comes in: <code>miou</code> will interrupt the domain to tell it that something in its tasks has changed (cancellation). The domain will then recalculate these tasks and re-observe their states before finally realising that the task it was doing has just been cancelled.</p><p>The problem is that this interrupt must also interrupt our <code>Unix.sleepf</code> on which our domain is based. It's here, in our <code>events</code> function, that we're going to replace <code>Unix.sleepf</code> (which can't be interrupted) with <code>Unix.select</code>!</p><p>In fact, <code>Unix.select</code> can both wait (like <code>Unix.sleepf</code>) and interrupt itself if an event occurs on one of its file-descriptors. We are going to use the latter mechanism to implement an <i>interrupt</i> mechanism. To do this, we need to create a pipe (<code>Unix.pipe</code>). The <code>interrupt</code> function will be called by <code>miou</code> whenever domains need to be interrupted (as in the case of cancellation). This interruption consists of writing to one side of the pipe while <code>Unix.select</code> observes the other side.</p><p>We also need to handle only promises that are pending. A cancellation changes the state of our promise and we need to &quot;clean up&quot; the promises that have been cancelled by <code>miou</code> in our sleepers.</p><p>Finally, we will have to manage 2 cases, the one where we receive an interrupt and the one where we have just consumed the minimum amount of time between all our sleepers. In the first case, we'll need to consume the byte sent to us by <code>miou</code>, while the second case is similar to what we did before.</p><pre class="language-ocaml"><code>let rec consume_interrupt ic =
  if Unix.read ic (Bytes.create 1) 0 1 = 0 then consume_interrupt ic

let update sleepers n =
  Hashtbl.filter_map_inplace
    (fun _ (prm, until) -&gt;
      let until' = Float.max 0. (until -. n) in
      Some (prm, until'))
    sleepers

let select interrupt () =
  let sleepers = sleepers () in
  (* clean-up our sleepers. *)
  Hashtbl.filter_map_inplace
    (fun _ (prm, until) -&gt;
      if Miou.is_pending prm then Some (prm, until) else None)
    sleepers;
  let min =
    Hashtbl.fold
      (fun uid (prm, until) -&gt; function
        | Some (_uid', _prm', until') when until &lt; until' -&gt;
            Some (uid, prm, until)
        | Some _ as acc -&gt; acc
        | None -&gt; Some (uid, prm, until))
      sleepers None
  in
  let ts =
    Option.map (fun (_, _, until) -&gt; until) min |&gt; function
    | Some ts -&gt; ts
    | None -&gt; 0. (* don't wait *) in
  let t0 = Unix.gettimeofday ()
  (* we must record how long we [select ()] to update then our [sleepers]. *)
  match Unix.select [ interrupt ] [] [] ts with
  | [], _, _ -&gt; (
    (* no interruption *)
    let t1 = Unix.gettimeofday () in
    update sleepers (t1 -. t0);
    match min with
    | Some (uid, prm, _) -&gt;
      Hashtbl.remove sleepers uid;
      [ Miou.task prm (Fun.const ()) ]
    | None -&gt; [])
  | _ -&gt;
    (* we got an interruption signal *)
    let t1 = Unix.gettimeofday () in
    consume_interrupt interrupt;
    update sleepers (t1 -. t0);
    []

let events _ =
  let ic, oc = Unix.pipe ~cloexec:true () in
  let rec interrupt () =
    if Unix.write oc (Bytes.make 1 '\000') 0 1 = 0 then interrupt () in
  { Miou.select= select ic; interrupt }</code></pre><p>And there you have it, if you run our example code with cancellation, you can see the interrupt mechanism and the fact that one of our promises is no longer waiting to be resolved (since it has been cancelled by <code>miou</code>). And our program finishes after 1 second.</p><p>This code shows the basic architecture of a real scheduler. We centralise everything around the <code>select</code> (which can become <code>poll</code> or something else). Quite a few issues have not been mentioned here (such as signal management, system interruption, or how to properly close our pipes). Above all, this means that this code is just an example! It does, however, give a general idea of how <code>miouu</code> (<code>miou</code>'s Unix extension) works and how you can extend <code>miou</code> for more specific applications.</p><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>The objective of such composability lies in our experience with the use of several systems, up to the most exotic (such as unikernels), where the ambition to centralise all the subtleties of these systems in a 'portable' implementation ultimately remains a vain ambition.</p><p>We can, and do, acknowledge the differences between systems, but also acknowledge the differences in the way in which the events of these systems are managed. Indeed, there may be alternatives (sometimes more effective) for managing events that may be in opposition to a more traditional vision (such as the use of <code>select</code>).</p><p>Finally, such an ambition requires quite a lot of work, which we can't commit to in the (very) long term given the resources we have. We prefer to leave room for future contributors and users who will surely have more time and more skills in this area.</p><p>At the very least, we hope that this little tutorial has taught you a little more about OCaml, Miou and schedulers. Who knows, you might be able to make your own!</p></div></body></html>