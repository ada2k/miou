<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>State (miou.Miou.State)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">miou</a> &#x00BB; <a href="../index.html">Miou</a> &#x00BB; State</nav><header class="odoc-preamble"><h1>Module <code><span>Miou.State</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#an-introduction-about-miou's-internals.">An introduction about Miou's internals.</a><ul><li><a href="#note-about-the-effect-module.">Note about the <code>Effect</code> module.</a></li><li><a href="#the-goal-of-this-interface.">The goal of this interface.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="an-introduction-about-miou's-internals."><a href="#an-introduction-about-miou's-internals." class="anchor"></a>An introduction about Miou's internals.</h2><p>This module proposes a re-interpretation of the effects management offered by OCaml 5 centered on the idea necessary in the implementation of a round-robin scheduler. For simplicity, as soon as we talk about scheduler, we will talk about round-robin scheduler. This one focuses on:</p><ul><li>simplicity of understanding and ease of implementation</li><li>solving the starvation problem</li><li>the communist idea of being able to fairly share the CPU time to our tasks</li></ul><p>In this sense, the scheduler needs basic operations in the manipulation of tasks. Tasks are the functions (in the OCaml sense) to be executed. The scheduler must be able to:</p><ol><li>launch a task / apply a function</li><li>stop a task at a specific point according to a metric</li><li>have a representation of this suspended task (a <i>state</i>) and be able to store it</li><li>restart a task from its state</li></ol><p>Usually, the metric used to &quot;stop&quot; a task is time. That is to say that we could stop a task after 100ms has elapsed for example. Unfortunately, it seems difficult to translate this into OCaml. In this sense, the choice of our <i>metric</i> is: <b>effect</b>. That is to say that a task can only emit <i>quanta</i> effects (which we will of course have to manage). The <i>quanta</i> is the number of effects the task can produce.</p><h4 id="note-about-the-effect-module."><a href="#note-about-the-effect-module." class="anchor"></a>Note about the <code>Effect</code> module.</h4><p>If you follow us well and you are already familiar with the effects module in OCaml, you suspect that our implementation currently uses the <code>Effect</code>.Shallow module which allows you to manage 1 effect (and only one).</p><p>It is allowed to use the <code>Effect</code>.Deep module for the implementation of a scheduler - the latter makes it possible to manage several effects until a <i>certain</i> state of the function is obtained. In this case, when using the <code>Effect</code>.Deep module, we spontaneously obtain 2 states:</p><ul><li>a suspended state because we have obtained a blocking effect</li><li>or a task termination state.</li></ul><p>Note, however, the subtlety of the first in relation to what we want to &quot;observe&quot; of a task for our scheduler. This case explains the fact that the task stopped on a blocking event. We consider that this subtlety <i>discriminates</i> the tasks (which is in opposition to our communist ideal) between those which block and those which do not block.</p><p>In this sense, in our ideal and according to what is required by a round-robin scheduler, the suspension mechanism (stop a task) intervenes <b>systematically</b> for each effect. Discrimination must be radically combated.</p><h4 id="the-goal-of-this-interface."><a href="#the-goal-of-this-interface." class="anchor"></a>The goal of this interface.</h4><p>This module therefore allows us to &quot;drive&quot; our development on these principles described above - indeed, the <code>Effect</code> module is perhaps a little too permissive. Thus, if you have to modify this module and specifically this interface, beware of a &quot;balkanization&quot; effect which could betray our ideals.</p><div class="odoc-spec"><div class="spec type anchored" id="type-continuation"><a href="#type-continuation" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) continuation</span></span></code></div><div class="spec-doc"><p>The type of continuations. <code>('a, 'b) continuation</code> is the state of a function <code>_ -&gt; 'b</code>. <code>'a</code> is the type of the value to <i>continue</i> the continuation. The user can also <i>discontinue</i> with an exception the continuation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span class="keyword">private</span> </span></code><ol><li id="type-t.Finished" class="def variant constructor anchored"><a href="#type-t.Finished" class="anchor"></a><code><span>| </span><span><span class="constructor">Finished</span> <span class="keyword">of</span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></li><li id="type-t.Suspended" class="def variant constructor anchored"><a href="#type-t.Suspended" class="anchor"></a><code><span>| </span><span><span class="constructor">Suspended</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-continuation">continuation</a></span> * <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Effect.t</span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></li></ol></div><div class="spec-doc"><p>The type of function states.</p><p>The state of a function is its execution state. A function can finish with its return value or an exception, or it can suspend on an <code>'aEffect</code>.t. In the case of a suspension, the user can &quot;continue&quot; the execution via what is expected by the function depending on the effect and the function <a href="#val-once"><code>once</code></a>. Note that <a href="#val-once"><code>once</code></a> can only be used <b>once</b> on a given value (otherwise, an exception <code>Continuation_already_resumed</code> is raised by OCaml).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make fn value</code> makes a new <i>function state</i> by executing the function with the given argument.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-step"><a href="#type-step" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a step</span></span><span> = </span></code><ol><li id="type-step.Send" class="def variant constructor anchored"><a href="#type-step.Send" class="anchor"></a><code><span>| </span><span><span class="constructor">Send</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-step.Fail" class="def variant constructor anchored"><a href="#type-step.Fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Fail</span> <span class="keyword">of</span> exn</span></code></li><li id="type-step.Intr" class="def variant constructor anchored"><a href="#type-step.Intr" class="anchor"></a><code><span>| </span><span><span class="constructor">Intr</span></span></code></li><li id="type-step.Cont" class="def variant constructor anchored"><a href="#type-step.Cont" class="anchor"></a><code><span>| </span><span><span class="constructor">Cont</span> : <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Effect.t</span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-step">step</a></span></span></code></li><li id="type-step.Yield" class="def variant constructor anchored"><a href="#type-step.Yield" class="anchor"></a><code><span>| </span><span><span class="constructor">Yield</span> : <span>unit <a href="#type-step">step</a></span></span></code></li></ol></div><div class="spec-doc"><p>Type of a step.</p><p>A <i>step</i> is how we want to continue (or not) a function state (see <a href="#type-t"><code>t</code></a>). The user <i>continue</i> the execution of the given function state (see <a href="#type-step.Send"><code>Send</code></a>), <i>discontinue</i> it with an exception (see <a href="#type-step.Fail"><code>Fail</code></a>), do nothing (see <a href="#type-step.Intr"><code>Intr</code></a>) or replace the current effect by an another one (see <a href="#type-step.Cont"><code>Cont</code></a> as long as it expects the same type as the previous effect).</p><p><a href="#type-step.Yield"><code>Yield</code></a> actually <i>continue</i> the execution of the given function state but then stops, even if there is still a number of <i>quanta</i> available when <a href="#val-run"><code>run</code></a> is used. It behaves in the same way as <a href="#type-step.Send"><code>Send</code></a> if you use <a href="#val-once"><code>once</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-k"><a href="#type-k" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) k</span></span><span> = <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-step">step</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Effect.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-perform"><a href="#type-perform" class="anchor"></a><code><span><span class="keyword">type</span> perform</span><span> = </span><span>{</span></code><ol><li id="type-perform.perform" class="def record field anchored"><a href="#type-perform.perform" class="anchor"></a><code><span>perform : 'a 'b. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-k">k</a></span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type of the effect handler.</p><p><code>perform</code> is a function which should handle incoming effects and give a <a href="#type-step"><code>step</code></a> to the given <code>k</code> according to the effect received. It's the <i>effect handler</i>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-once"><a href="#val-once" class="anchor"></a><code><span><span class="keyword">val</span> once : <span>perform:<a href="#type-perform">perform</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>once ~perform state</code> applies <code>perform</code> once on the given state if the latter emits an effect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span>exn:exn <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail ~exn state</code> discontinue the given state with the given exception. It always return <code>Finished (Error exn)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span><span class="keyword">val</span> pure : <span><span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pure value</code> returns <code>Finished value</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span>quanta:int <span class="arrow">&#45;&gt;</span></span> <span>perform:<a href="#type-perform">perform</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>run ~quanta ~perform state</code> applies <a href="#val-once"><code>once</code></a> <code>quanta</code> times. If <code>perform</code> responds with <a href="#type-step.Intr"><code>Intr</code></a> (and therefore does nothing), even though there may be a few <i>quanta</i> left, the function returns the last state obtained.</p><p>The same applies to <a href="#type-step.Yield"><code>Yield</code></a>, except that the continuation has burnt itself out. In other words, <a href="#type-step.Yield"><code>Yield</code></a> is equivalent to <code>Send (); Intr</code> but costs only one <i>quanta</i>.</p></div></div></div></body></html>