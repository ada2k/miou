<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Miou (miou.Miou)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">miou</a> &#x00BB; Miou</nav><header class="odoc-preamble"><h1>Module <code><span>Miou</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#a-promise-for-a-better-futur.">A promise for a better futur.</a><ul><li><a href="#daemon-and-orphan-tasks.">Daemon and orphan tasks.</a></li><li><a href="#launch-a-promise.">Launch a promise.</a></li><li><a href="#await-a-promise.">Await a promise.</a></li><li><a href="#state-introspection.">State introspection.</a></li><li><a href="#syscalls.">Syscalls.</a></li></ul></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Queue/index.html">Queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A lock-free queue.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Domain_id"><a href="#module-Domain_id" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Domain_id/index.html">Domain_id</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An unique identifier for domains.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Id/index.html">Id</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A unique identifier for promises.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ownership"><a href="#module-Ownership" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ownership/index.html">Ownership</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A capitalism idea into our scheduler.</p></div></div><h2 id="a-promise-for-a-better-futur."><a href="#a-promise-for-a-better-futur." class="anchor"></a>A promise for a better futur.</h2><p>A <b>promise</b> is a function (<code>unit -&gt; 'a</code>) that will be executed by the scheduler in the near future. The user can launch a promise (and notify by this way the scheduler of a new task to do) as well as wait for the result of a promise (see <a href="#val-await"><code>await</code></a>).</p><p>A promise can be executed concurrently with other promises (see <a href="#val-call_cc"><code>call_cc</code></a>) or in parallel with other promises (see <a href="#val-call"><code>call</code></a>).</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of promises.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A simple pretty-printer of a promise which shows you the domain where the promise run and its unique ID.</p></div></div><h3 id="daemon-and-orphan-tasks."><a href="#daemon-and-orphan-tasks." class="anchor"></a>Daemon and orphan tasks.</h3><p>The prerogative of absolutely expecting all of its direct children limits the user to considering certain anti-patterns. The best known is the <i>background</i> task: this consists of running a task that we would like to 'detach' from the main task so that it can continue its life in autonomy.</p><p>Not that we want to impose an authoritarian family approach, but the fact remains that these <i>orphaned</i> tasks have resources that we need to manage and free up (even in an abnormal situation). And we'd like to sleep easy tonight.</p><p>So a promise can be associated with an <a href="#type-orphans"><code>orphans</code></a>. The latter will then collect the results of the associated promise tasks and give you back the promises (via <a href="#val-care"><code>care</code></a>) in a 'non-blocking' mode: applying <a href="#val-await"><code>await</code></a> to them will give you the results directly.</p><p>In this way, by creating promises associated with this <a href="#type-orphans"><code>orphans</code></a> value, we can at the same time &quot;clean up&quot; these <i>background</i> tasks, as this code shows:</p><pre class="language-ocaml"><code>let rec clean_up orphans =
  match Miou.care orphans with
  | None -&gt; ()
  | Some prm -&gt; Miou.await_exn prm; clean_up orphans

let server orphans =
  clean_up orphans;
  ignore (Miou.call ~orphans handler);
  server orphans in
server (Miou.oprhans ())</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-orphans"><a href="#type-orphans" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a orphans</span></span></code></div><div class="spec-doc"><p>The type of orphan collectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-orphans"><a href="#val-orphans" class="anchor"></a><code><span><span class="keyword">val</span> orphans : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span></span></code></div><div class="spec-doc"><p><code>orphans ()</code> makes a new orphan collectors which can be used by <a href="#val-call"><code>call</code></a> and <a href="#val-call_cc"><code>call_cc</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : <span><span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>care orphans</code> returns a <i>ready-to-await</i> promise or <code>None</code>. The user must <i>consume</i> the result of the promise with <a href="#val-await"><code>await</code></a>. Otherwise, <code>miou</code> will raises <code>Still_has_children</code>.</p></div></div><h3 id="launch-a-promise."><a href="#launch-a-promise." class="anchor"></a>Launch a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-call_cc"><a href="#val-call_cc" class="anchor"></a><code><span><span class="keyword">val</span> call_cc : 
  <span>?orphans:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?give:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call_cc fn</code> (for Call with Current Continuation) returns a promise which will be executed <b>cooperatively</b> with other promises.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call"><a href="#val-call" class="anchor"></a><code><span><span class="keyword">val</span> call : 
  <span>?orphans:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?give:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call fn</code> returns a promise which will be executed <b>in parallel</b> with other promises. <code>miou</code> pre-allocates domains that are waiting to perform this kind of task. The user does <b>not</b> choose the domain on which the task will be executed. <code>miou</code> <b>randomly</b> chooses which of the domains will perform the task. The task will <b>never</b> run into the domain which launches the promise. For instance:</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let p = Miou.call @@ fun () -&gt;
    let q = Miou.call @@ fun () -&gt; 42 in
    await_exn q in
  await_exn p</code></pre><p>In this example, <code>q</code> will always run into another domain than <code>p</code>. However, a subsequent call to <a href="#val-call"><code>Miou.call</code></a> does <b>not</b> ensure that tasks will run into different domains. For instance, this output is valid:</p><pre class="language-ocaml"><code># let prgm () = Format.printf &quot;Run into %a\n%!&quot;
    Miou.Domain_id.pp (Domain_id.self ()) ;;
# let () = Miou.run @@ fun () -&gt;
    let p0 = Miou.call prgm in
    let p1 = Miou.call prgm in
    Miou.await_all [ p0; p1 ] ;;
Run into 1
Run into 1</code></pre><p>If you want to run multiple tasks on different domains, you can use <a href="#val-parallel"><code>parallel</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parallel"><a href="#val-parallel" class="anchor"></a><code><span><span class="keyword">val</span> parallel : <span><span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span></span></code></div><div class="spec-doc"><p><code>parallel [ fun () -&gt; ...; fun () -&gt; ...]</code> assigns a task from the list to each domain. If the list contains more tasks than domains, we raise an exception. This ensures that several tasks run in parallel - unlike several calls to <a href="#val-call"><code>Miou.call</code></a>, which only ensures that the task is run in a different domain from the launcher.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cancelled"><a href="#exception-Cancelled" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cancelled</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel prm</code> asynchronously tries to cancel the given promise <code>prm</code>. <code>miou</code> allows the forgetting of a cancelled promise and the forgetting of its children. For instance, this code is valid (despite the second one):</p><pre class="language-ocaml"><code># Miou.(run @@ fun () -&gt;
        ignore (cancel (call (Fun.const ())))) ;;
- : unit = ()
# Miou.(run @@ fun () -&gt;
        ignore (call (Fun.const ()))) ;;
Exception: Miou.Still_has_children</code></pre><p>Cancellation will try to finish all the children and will wait until all the children are finished (once again, termination intervenes if the promise has been cancelled <b>or</b> resolved). You can sleep soundly after the cancellation, and the promise that all its children have stopped.</p></div></div><h3 id="await-a-promise."><a href="#await-a-promise." class="anchor"></a>Await a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_exn"><a href="#val-await_exn" class="anchor"></a><code><span><span class="keyword">val</span> await_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_one"><a href="#val-await_one" class="anchor"></a><code><span><span class="keyword">val</span> await_one : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_all"><a href="#val-await_all" class="anchor"></a><code><span><span class="keyword">val</span> await_all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_first"><a href="#val-await_first" class="anchor"></a><code><span><span class="keyword">val</span> await_first : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><h3 id="state-introspection."><a href="#state-introspection." class="anchor"></a>State introspection.</h3><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a state</span></span><span> = </span></code><ol><li id="type-state.Resolved" class="def variant constructor anchored"><a href="#type-state.Resolved" class="anchor"></a><code><span>| </span><span><span class="constructor">Resolved</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Normal termination.</p><span class="comment-delim">*)</span></div></li><li id="type-state.Failed" class="def variant constructor anchored"><a href="#type-state.Failed" class="anchor"></a><code><span>| </span><span><span class="constructor">Failed</span> <span class="keyword">of</span> exn</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Abnormal termination.</p><span class="comment-delim">*)</span></div></li><li id="type-state.Pending" class="def variant constructor anchored"><a href="#type-state.Pending" class="anchor"></a><code><span>| </span><span><span class="constructor">Pending</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Not yet resolved.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state"><a href="#val-state" class="anchor"></a><code><span><span class="keyword">val</span> state : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-state">state</a></span></span></code></div><div class="spec-doc"><p><code>state prm</code> returns the current state of the given promise <a href="#type-t"><code>t</code></a> <code>prm</code>.</p></div></div><h3 id="syscalls."><a href="#syscalls." class="anchor"></a>Syscalls.</h3><p><code>miou</code> does not interact with the system, only with the OCaml runtime. As a result, it does not implement the usual input/output operations. Nevertheless, it offers a fairly simple API for using functions that interact with the system (and that can, above all, block).</p><p>One of the rules of <code>miou</code> is never to give it blocking functions to eat (in fact, it has very strict - but very simple - nutritional constraints).</p><p>On the other hand, the system can inform you when a function is non-blocking (and can therefore be given to <code>miou</code>). The idea is to inform <code>miou</code> of the existence of a <i>promise</i>, which it will then try to resolve. Of course, it won't be able to, but as a last resort, <code>miou</code> will come back to you to ask for a possible task to resolve this promise. It will do this via an user's defined function, which you can specify using the <a href="#val-run"><code>run</code></a> function (see <code>events</code> argument).</p><p>This user's defined function return a <a href="#type-task"><code>task</code></a> which is a promise associated with a <b>non-blocking</b> task (<code>unit -&gt; unit</code>) that would resolve it. At last, <code>miou</code> will be able to fulfil your promise!</p><p>For more information on this API, a tutorial is available on how to implement <a href="../sleepers.html"><code>sleepers</code></a>: tasks that block your process for a time.</p><div class="odoc-spec"><div class="spec type anchored" id="type-syscall"><a href="#type-syscall" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a syscall</span></span></code></div><div class="spec-doc"><p>The type of <i>syscalls</i>.</p><p>A syscall is like a promise (see <a href="#type-t"><code>t</code></a>), but the user can only <a href="#val-suspend"><code>suspend</code></a> the execution flow with it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>?give:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span></span></code></div><div class="spec-doc"><p><code>make return</code> creates a <i>promise</i> that will <b>never</b> be resolved. For the example, this code fails:</p><pre class="language-ocaml"><code># Miou.(run @@ fun () -&gt; let v = make (Fun.const ()) in
        suspend v) ;;
Exception: Miou.Still_has_children</code></pre><p>However, if you keep this promise somewhere and specify a &quot;select&quot; function that proposes a task to resolve it, the program should then terminate:</p><pre class="language-ocaml"><code># let global = ref None ;;
# let select () = match !global with
  | Some p -&gt; [ Miou.task p (fun () -&gt; global := None) ]
  | None -&gt; []
  ;;
# let events = { Miou.select; Miou.interrupt= ignore } ;;
# Miou.(run ~events @@ fun () -&gt;
  let v = make (Fun.const ()) in
  global := Some v; suspend v) ;;
- : (unit, exn) result = Ok ()</code></pre><p>As you can see, the use of <a href="#val-make"><code>make</code></a> is very intrinsic to the creation of the <code>events</code> function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span><span class="keyword">val</span> suspend : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>suspend syscall</code> suspends the execution flow and will be resumed when the user gives a <b>non-blocking</b> function (a <a href="#type-task"><code>task</code></a>) via <a href="#type-events"><code>events</code></a> that resolves the syscall.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_pending"><a href="#val-is_pending" class="anchor"></a><code><span><span class="keyword">val</span> is_pending : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_pending syscall</code> returns <code>true</code> if the given <code>syscall</code> is not yet resolved (or cancelled). This function can be useful to <i>clean-up</i> syscalls that have been cancelled by <code>miou</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid"><a href="#val-uid" class="anchor"></a><code><span><span class="keyword">val</span> uid : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="Id/index.html#type-t">Id.t</a></span></code></div><div class="spec-doc"><p><code>uid syscall</code> returns a unique identifier of the promise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> reschedules tasks and give a chance to all of them to be executed then. For instance:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (fun () -&gt; print_endline &quot;Hello&quot;) in
  print_endline &quot;World&quot;;
  Miou.await_exn prm ;;
World
Hello
- : unit = ()
# Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (fun () -&gt; print_endline &quot;Hello&quot;) in
  yield ();
  print_endline &quot;World&quot;;
  Miou.await_exn prm ;;
Hello
World
- : unit = ()</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-task"><a href="#type-task" class="anchor"></a><code><span><span class="keyword">type</span> task</span></code></div><div class="spec-doc"><p>Type of tasks.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-events"><a href="#type-events" class="anchor"></a><code><span><span class="keyword">type</span> events</span><span> = </span><span>{</span></code><ol><li id="type-events.interrupt" class="def record field anchored"><a href="#type-events.interrupt" class="anchor"></a><code><span>interrupt : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-events.select" class="def record field anchored"><a href="#type-events.select" class="anchor"></a><code><span>select : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-task">task</a> list</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-task"><a href="#val-task" class="anchor"></a><code><span><span class="keyword">val</span> task : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-task">task</a></span></code></div><div class="spec-doc"><p><code>task prm fn</code> creates a new task associated with a <a href="#type-syscall"><code>syscall</code></a> created by the user. The task must be a non-blocking function to resolve the associated promise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span>?g:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span>?domains:int <span class="arrow">&#45;&gt;</span></span>
  <span>?events:<span>(<span><a href="Domain_id/index.html#type-t">Domain_id.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-events">events</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div></div></body></html>