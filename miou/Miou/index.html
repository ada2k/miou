<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Miou (miou.Miou)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">miou</a> &#x00BB; Miou</nav><header class="odoc-preamble"><h1>Module <code><span>Miou</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#miou,-a-simple-scheduler-for-ocaml-5.">Miou, a simple scheduler for OCaml 5.</a><ul><li><a href="#basics.">Basics.</a><ul><li><a href="#effects.">Effects.</a></li><li><a href="#a-task-manager.">A task manager.</a></li><li><a href="#domains.">Domains.</a></li></ul></li><li><a href="#design.">Design.</a><ul><li><a href="#preemption-and-cooperation">Preemption and cooperation</a><ul><li><a href="#availability.">Availability.</a></li><li><a href="#cooperation-and-effects.">Cooperation and effects.</a></li><li><a href="#performance-and-events.">Performance and events.</a></li></ul></li><li><a href="#miou-and-the-system.">Miou and the system.</a><ul><li><a href="#suspension-points.">Suspension points.</a></li><li><a href="#the-select()-function.">The <code>select()</code> function.</a></li></ul></li><li><a href="#user-task-management.">User task management.</a><ul><li><a href="#rule-1,-await-for-all-your-tasks.">Rule 1, await for all your tasks.</a></li><li><a href="#rule-2,-only-await-for-direct-children.">Rule 2, only await for direct children.</a></li><li><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled.">Rule 3, a task can only be awaited or cancelled.</a></li><li><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished.">Rule 4, a task only finishes after its children have finished.</a></li><li><a href="#background">Rule 5, background tasks.</a></li><li><a href="#rule-6,-a-parallel-task-will-never-appear-in-the-main-domain.">Rule 6, a parallel task will never appear in the main domain.</a></li><li><a href="#rule-7,-suspension-points-are-local-to-the-domain.">Rule 7, suspension points are local to the domain.</a></li></ul></li></ul></li><li><a href="#orphans">Daemon and orphan tasks.</a></li><li><a href="#launch-a-promise.">Launch a promise.</a></li><li><a href="#system">System events.</a><ul><li><a href="#domains,-suspension-and-monitoring.">Domains, suspension and monitoring.</a></li><li><a href="#sleep-state.">Sleep state.</a></li><li><a href="#cancellation.">Cancellation.</a></li><li><a href="#tutorial.">Tutorial.</a></li></ul></li><li><a href="#await-a-promise.">Await a promise.</a></li><li><a href="#cancellation._2">Cancellation.</a></li><li><a href="#composition.">Composition.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="miou,-a-simple-scheduler-for-ocaml-5."><a href="#miou,-a-simple-scheduler-for-ocaml-5." class="anchor"></a>Miou, a simple scheduler for OCaml 5.</h2><p>Miou is a simple scheduler for OCaml 5 that uses effects. It allows you to launch tasks (functions) concurrently and/or in parallel, as well as offering your application high availability to system events.</p><h3 id="basics."><a href="#basics." class="anchor"></a>Basics.</h3><h4 id="effects."><a href="#effects." class="anchor"></a>Effects.</h4><p>Since OCaml 5, it has been possible to use effects. An effect allows you to suspend the execution of a function and <i>fall</i> into a handler which, depending on the effect, would perform a specific operation that would <i>continue</i> the suspended function with the result of the operation.</p><p>For example, a <code>Hello: unit Effect.t</code> effect can suspend using <code>Effect.perform</code>. A pre-installed <i>handler</i> will then retrieve this effect, perform the operation (say, display <code>&quot;Hello&quot;</code>), and unsuspend the function with the result of the operation (here, <code>() : unit</code>).</p><pre class="language-ocaml"><code>type _ Effect.t += Hello : unit Effect.t

let handler =
  let retc = Fun.id in
  let exnc = raise in
  let effc
    : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'a) option
    = function
    | Hello -&gt;
      Some (fun k -&gt; continue k (print_endline &quot;Hello&quot;))
    | _ -&gt; None in
  { retc; exnc; effc }

let my_function () =
  Effect.perform Hello;
  print_endline &quot;World&quot;

let () = match_with my_function () handler</code></pre><p>To go back to familiar OCaml elements, an effect is like an exception in that it breaks the execution flow. The &quot;handler&quot; is the <code>with ...</code> part of a <code>try ... with ...</code> in OCaml, and its installation corresponds to the <code>try ...</code>. Finally, and this is the fundamental difference with exceptions, there is the <i>continuation</i> which allows us to return to the point where the effect was launched.</p><pre class="language-ocaml"><code>exception Hello

let my_function () =
  raise Hello;
  print_endline &quot;World&quot;

let () =
  try my_function ()
  with Hello k -&gt;
    print_endline &quot;Hello&quot;;
    k ()</code></pre><p>Miou defines several effects that allow the user to interact with Miou's &quot;task manager&quot;. Miou's effects manager is installed using <a href="#val-run"><code>run</code></a>. So, if you want to use Miou, you should always start with <a href="#val-run"><code>run</code></a>:</p><pre class="language-ocaml"><code>val my_program : unit -&gt; unit

let () = Miou.run my_program ()</code></pre><h4 id="a-task-manager."><a href="#a-task-manager." class="anchor"></a>A task manager.</h4><p>Miou is a task manager. In other words, it manages a list of to-do tasks (which you can add to with <a href="#val-call_cc"><code>call_cc</code></a>/<a href="#val-call"><code>call</code></a>) and allows the user to manage these tasks. When a task is created, Miou gives the user a representation of the task: a promise <a href="#type-t"><code>t</code></a>.</p><p>From this promise, the user can:</p><ol><li><a href="#val-await"><code>await</code></a> for the result of the task</li><li><a href="#val-cancel"><code>cancel</code></a> the task</li></ol><p>Here's an example where a list of tasks are initiated and awaited. Interaction (task creation and awaiting) with Miou takes place via effects. Miou manages the execution order of these tasks and attempts to finish them all in order to terminate your program.</p><pre class="language-ocaml"><code>let digest filename =
  Miou.call_cc @@ fun () -&gt;
  (filename, Digest.file filename)

let my_program filenames =
  (* 1) we create a list of tasks *)
  let prms = List.map digest filenames in
  (* 2) Miou manages the execution of these tasks *)
  (* 3) we wait these tasks *)
  let results = List.map Miou.await_exn prms in
  (* 4) we print results *)
  List.iter (fun (filename, hash) -&gt;
    Format.printf &quot;%s: %s\n%!&quot; filename (Digest.to_hex hash))
    results

let () = Miou.run @@ fun () -&gt;
  my_program [&quot;file01.ml&quot;; &quot;file02.ml&quot;]</code></pre><p>Miou suggests a <a href="../scheduler.html" title="scheduler">little exercise</a> to implement a task manager with effects. It explains the role of promises, creation and awaiting for a task (it does not, however, describe cancellation).</p><h4 id="domains."><a href="#domains." class="anchor"></a>Domains.</h4><p>Since OCaml 5, it has been possible to run functions in parallel. These functions run on a domain that has its own minor heap - so allocating small amounts of data doesn't require synchronization with other domains. Miou provides a <i>pool</i> of domains to which the user can assign tasks to run in parallel.</p><pre class="language-ocaml"><code># let dom = Stdlib.Domain.spawn my_parallel_computation ;;
# Stdlib.Domain.join dom ;;</code></pre><p>For more details on parallelism and garbage collection, we recommend reading the OCaml manual.</p><p>Miou prepares the allocation of a certain number of domains in advance. These will be waiting for tasks. The <a href="#val-call"><code>call</code></a> function is used to assign a new task to one of these domains. The user can specify the number of domains Miou can allocate via the <code>domains</code> argument to the <a href="#val-run"><code>run</code></a> function. We recommend using <code>Domain.recommended_domain_count () - 1</code> domains.</p><h3 id="design."><a href="#design." class="anchor"></a>Design.</h3><p>After this brief introduction to the basics of Miou (i.e. the use of effects and domains and the definition of a task manager), Miou stands out from other schedulers through its design, which we'll describe here.</p><p>However, we need to define 3 terms that will be used throughout this description:</p><ul><li>a <i>task</i> is the smallest sequence of programmed instructions that can be managed by Miou. In concrete terms, it's an OCaml function.</li><li>a domain (see <a href="Domain/index.html"><code>Domain</code></a> is a resource representing a processor available to execute a task</li><li>a <i>fiber</i> is a task that will run on a domain in cooperation with other tasks</li></ul><h4 id="preemption-and-cooperation"><a href="#preemption-and-cooperation" class="anchor"></a>Preemption and cooperation</h4><p>OCaml offers only a fundamentally cooperative model for executing these tasks. Indeed, there are no mechanisms in OCaml to force the suspension of a given task. However, a given task can suspend itself in order to cooperate with other tasks on a limited resource such as a particular domain.</p><p>Miou offers a way of creating tasks (see <a href="#val-call_cc"><code>call_cc</code></a>) that are more precisely called <i>fibers</i>. These fibers must cooperate with each other to share the domain on which they run. This means that a fiber should not have exclusive domain control when other fibers are waiting to be executed.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let rec pr str n =
    if n &gt;= 0 then
    begin Miou.yield (); print_endline str; pr str (pred n) end in
  let prm0 = Miou.call_cc @@ fun () -&gt; pr &quot;Hello&quot; 1 in
  let prm1 = Miou.call_cc @@ fun () -&gt; pr &quot;World&quot; 1 in
  Miou.await_exn prm0;
  Miou.await_exn prm1 ;;
Hello
World
Hello
World
- : unit = ()</code></pre><p>This task cooperation is achieved by <a href="#val-yield"><code>yield</code></a>, which interrupts the current task to leave the domain to another waiting task.</p><p>The problem with cooperation is that it does not take into account the irruption of external elements such as system events. Miou's objective is to be able to <i>interrupt</i> your application as soon as these events occur: in other words, to <b>preempt</b> the interruption of your tasks when these events occur.</p><h5 id="availability."><a href="#availability." class="anchor"></a>Availability.</h5><p>If it's important for us to interrupt your application as soon as these events are received, it's to increase the availability of your application to handle these events.</p><p>Let's take the example of a task making a long calculation. If an event such as the arrival of a TCP/IP connection were to occur at the same time as the calculation, we would consider the latter to be more important than the completion of the calculation. So we'd like to interrupt the calculation so that your application can handle this event as a priority.</p><pre class="language-ocaml"><code>let _, _ = Miou.run @@ fun () -&gt;
  let rec server () =
    let socket = accept () in
    let _ = Miou.call (handler socket) in
    server () in
  let prm0 = Miou.call_cc server in
  let prm1 = Miou.call_cc my_long_computation in
  Miou.both prm0 prm1 ;;

(* [my_long_computation] should have multiple cooperative points to let
   the other task (our [server]) to accept incoming TCP/IP connexions. *)</code></pre><p>In other words, your application is &quot;more&quot; available to handle events than to perform the calculations requested. This approach becomes interesting for services (such as an HTTP server) where the availability to handle such events is more important than prioritizing the calculation requested by a client.</p><h5 id="cooperation-and-effects."><a href="#cooperation-and-effects." class="anchor"></a>Cooperation and effects.</h5><p>And therein lies the crux of the problem: how do you preempt in a fundamentally cooperative system?</p><p>If we want to be in the best position to manage system events, we need to <i>increase</i> the points of cooperation that the fibers can emit. This is how Miou came up with a fundamental rule: <b>an effect yields</b>.</p><p>All effects (those defined by Miou as well as those defined by the user) reorder task execution. During this reordering, Miou can collect the system events that have just occurred. The objective is to do this as often as possible!</p><h5 id="performance-and-events."><a href="#performance-and-events." class="anchor"></a>Performance and events.</h5><p>At this point, we need to make clear to our future users a crucial choice we made for Miou: we prefer a scheduler that's available for system events, rather than one that performs well in calculations.</p><p>Indeed, on the cooperation points presented above, Miou will systematically ask whether any system events have occurred. However, if your ambition is to do nothing but calculations, the latter will be <i>&quot;polluted&quot;</i> by these unnecessary points of cooperation. So, by default, Miou is <b>less</b> efficient than other schedulers.</p><h4 id="miou-and-the-system."><a href="#miou-and-the-system." class="anchor"></a>Miou and the system.</h4><p>One of Miou's objectives is to be used in a unikernel. As far as the latter is concerned, possible interactions can be very limited. So we decided to separate the scheduler (<a href="#"><code>Miou</code></a>) from interactions with the underlying system (<a href="../Miou_unix/index.html"><code>Miou_unix</code></a> for a UNIX system).</p><p>There is a way to do this:</p><ol><li>define suspensions that will only be released when certain events occur</li><li>Miou can collect these events and we can tell it which suspension should be &quot;unblocked&quot; according to the collection.</li></ol><h5 id="suspension-points."><a href="#suspension-points." class="anchor"></a>Suspension points.</h5><p>Miou offers a way of creating what we call a suspension point. This can be created from a value <a href="#type-syscall"><code>syscall</code></a> (with a unique identifier) that the user can keep. This suspension point can be &quot;unblocked&quot; if the <a href="#type-select"><code>select</code></a> function given to Miou (via <a href="#val-run"><code>run</code></a>) informs it of the &quot;continuation&quot; of this suspension.</p><p>Let's take <code>read()</code> as an example. This function, which interacts with the system, can &quot;block&quot; (for example, if you try to read from a socket). To avoid blocking (and leave it to the system), you can ask Miou to suspend just beforehand so that it can do other tasks, and inform Miou as soon as you know that this <code>read()</code> will not block.</p><pre class="language-ocaml"><code>let global = Hashtbl.create 0x100

let miou_read fd buf off len =
  let syscall = Miou.make (Fun.const ()) in
  Hashtbl.add global fd syscall;
  Miou.suspend syscall;
  Unix.read fd buf off len</code></pre><p>Here, we use a global table to remind us that the file-descriptor we're using is associated with a <a href="#type-syscall"><code>syscall</code></a> we've just created. The next objective is to define a <a href="#type-select"><code>select</code></a> function that will observe whether the added file-descriptor is ready to be read.</p><h5 id="the-select()-function."><a href="#the-select()-function." class="anchor"></a>The <code>select()</code> function.</h5><p>Miou lets you inject a function to observe system events. This should appear each time tasks are rescheduled, as explained above with regard to application availability. This function should return any suspension points that can be unblocked.</p><pre class="language-ocaml"><code>let select ~poll:_ _cancelled_points =
  let fds = Hashtbl.to_seq_keys global |&gt; List.of_seq in
  match Unix.select fds [] [] 0.1 with
  | fds -&gt;
    let continuations = List.map (fun fd -&gt;
      let syscall = Hashtbl.find global fd in
      Miou.continue_with syscall (fun () -&gt; Hashtbl.remove global fd))
      fds in
    continuations

let run fn =
  let events _domain =
    { Miou.select; interrupt= Fun.const () } in
  Miou.run ~events fn</code></pre><p>As you can see, the next step is to produce a <a href="#val-run"><code>run</code></a> function that uses our <code>select</code>. This is what <a href="../Miou_unix/index.html"><code>Miou_unix</code></a> proposes for the example. However, there are a number of unresolved issues:</p><ol><li>in particular, the cancellation of a task and its suspension point</li><li>or the ability to wait only for system events</li><li>or the ability to interrupt such an observation</li></ol><p>We recommend reading the chapter on <a href="#system" title="system">system events</a> and its tutorial on <a href="../sleepers.html"><code>sleepers</code></a>.</p><h4 id="user-task-management."><a href="#user-task-management." class="anchor"></a>User task management.</h4><p>Users can manipulate their tasks via their <i>promises</i> (see <a href="#type-t"><code>t</code></a>). A promise is an OCaml value representing the task. It can be used to <a href="#val-await"><code>await</code></a> for or <a href="#val-cancel"><code>cancel</code></a> a task. However, certain rules apply to its use.</p><h5 id="rule-1,-await-for-all-your-tasks."><a href="#rule-1,-await-for-all-your-tasks." class="anchor"></a>Rule 1, await for all your tasks.</h5><p>It is forbidden to forget your children. The creation of a task necessarily implies that the developer <a href="#val-await"><code>await</code></a>s or <a href="#val-cancel"><code>cancel</code></a>s the task afterwards:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt; Miou.call_cc (Fun.const ()) ;;
Exception: Miou.Still_has_children.</code></pre><h5 id="rule-2,-only-await-for-direct-children."><a href="#rule-2,-only-await-for-direct-children." class="anchor"></a>Rule 2, only await for direct children.</h5><p>You can only await for your direct children. Transferring a promise to another task so that it can await for it is illegal:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (Fun.const ()) in
  let q = Miou.call_cc (fun () -&gt; Miou.await_exn p) in
  Miou.await_all [ p; q ] |&gt; ignore
Exception: Miou.Not_a_child.</code></pre><p>Task relationship clarifies what is involved in managing tasks and what they should transmit to each other. To answer this question, users will have to find their own mechanisms (<i>mutex</i>, <i>condition</i>, <i>ipc</i>, etc.) to share results between tasks that are not directly related.</p><h5 id="rule-3,-a-task-can-only-be-awaited-or-cancelled."><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled." class="anchor"></a>Rule 3, a task can only be awaited or cancelled.</h5><p>Miou only allows you to await for or cancel a task. It is also impossible to detach a task. For more information on this subject, we recommend reading the <a href="#orphans" title="orphans">Daemon and orphan tasks.</a> section and our following rule: <a href="#background" title="background">background tasks</a>.</p><h5 id="rule-4,-a-task-only-finishes-after-its-children-have-finished."><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished." class="anchor"></a>Rule 4, a task only finishes after its children have finished.</h5><p>By extension, as soon as a task is finished, all its children are finished too. The same applies to cancellation. If you cancel a task, you also cancel its children.</p><h5 id="background"><a href="#background" class="anchor"></a>Rule 5, background tasks.</h5><p>There is, however, a <i>pattern</i> in which we'd like to put a task aside: in other words, forget about it for a while. Miou offers a specific API for this pattern, described <a href="#orphans" title="orphans">here</a>.</p><h5 id="rule-6,-a-parallel-task-will-never-appear-in-the-main-domain."><a href="#rule-6,-a-parallel-task-will-never-appear-in-the-main-domain." class="anchor"></a>Rule 6, a parallel task will never appear in the main domain.</h5><p>There may be a <i>contention</i> problem if you involve <code>dom0</code> in the tasks to be run in parallel. There may in fact be a situation where <code>dom0</code> is awaiting for <code>dom1</code>, which is awaiting for <code>dom0</code>.</p><p>Miou does not allow <code>dom0</code> to be assigned a parallel task. These assertions in the code below are true all the time.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let prm1 = Miou.call @@ fun () -&gt;
    let prm2 = Miou.call @@ fun () -&gt;
      Miou.Domain.self () in
    Miou.await_exn prm2, Miou.Domain.self () in
  let u, v = Miou.await_exn prm1 in
  assert (Miou.Domain.Uid.to_int u &lt;&gt; 0);
  assert (Miou.Domain.Uid.to_int v &lt;&gt; 0);
  assert (u &lt;&gt; v);;
- : unit = ()</code></pre><p>However, you can involve <code>dom0</code> in the calculations with <a href="#val-call_cc"><code>call_cc</code></a>.</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let prm = Miou.call_cc server in
  Miou.parallel server (List.init (Miou.Domain.count ()) (Fun.const ()))
  |&gt; List.iter (function Ok () -&gt; () | Error exn -&gt; raise exn);
  Miou.await_exn prm</code></pre><p>The above rule also limits the use of <a href="#val-call"><code>call</code></a> if you only have (or want) less than 3 domains. In fact, if you only have one domain, <a href="#val-call"><code>call</code></a> cannot launch tasks in parallel. In the event that you only have 2 domains, it is possible to launch a task in parallel from <code>dom0</code> but it is impossible to launch a task in parallel from this <code>dom1</code>.</p><p>In both cases and in such a situation, an exception is thrown: <a href="#exception-No_domain_available"><code>No_domain_available</code></a>.</p><h5 id="rule-7,-suspension-points-are-local-to-the-domain."><a href="#rule-7,-suspension-points-are-local-to-the-domain." class="anchor"></a>Rule 7, suspension points are local to the domain.</h5><p>A suspension point is local to the domain. This means that only the domain in which it was created can unlock it. The Event value is created for each domain created by Miou. The unique identifier is also local to the domain.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let fn () = let s = Miou.make (Fun.const ()) in Miou.uid s in
  let uids = Miou.parallel fn (List.init 2 (Fun.const ())) in
  let[@warning &quot;-8&quot;] [ a; b ] = List.map Result.get_ok uids in
  assert (a = b)
;;
- : unit = ()</code></pre><p>This code shows that two suspension points are created in two different domains and their unique ids are the same.</p><p>The advantage of making suspension points local to domains is that the domain is solely responsible for these points and there are no inter-domain transfer mechanisms for managing system events. For the example, <code>Domain.DLS</code> can be used for a table of current events in each domain.</p><pre class="language-ocaml"><code>let get, set =
  let make () = Hashtbl.create () in
  let dom = Stdlib.Domain.DLS.new_key make in
  let get () = Stdlib.Domain.DLS.get dom in
  let set value = Stdlib.Domain.DLS.set dom value in
  get, set

let miou_read fd buf off len =
  let syscall = Miou.make (Fun.const ()) in
  let tbl = get () in
  Hashtbl.add tbl fd syscall;
  set tbl;
  Miou.suspend syscall;
  Unix.read fd buf off len</code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-State"><a href="#module-State" class="anchor"></a><code><span><span class="keyword">module</span> <a href="State/index.html">State</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Queue/index.html">Queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ownership"><a href="#module-Ownership" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ownership/index.html">Ownership</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of promises.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Domain"><a href="#module-Domain" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Domain/index.html">Domain</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-self"><a href="#val-self" class="anchor"></a><code><span><span class="keyword">val</span> self : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="Promise/Uid/index.html#type-t">Promise.Uid.t</a> * <a href="Domain/Uid/index.html#type-t">Domain.Uid.t</a> * int</span></code></div><div class="spec-doc"><p><code>self ()</code> returns the unique ID of the current promise, the domain which runs the current promise and how many resources has the current promise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stats"><a href="#val-stats" class="anchor"></a><code><span><span class="keyword">val</span> stats : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>stats ()</code> returns the number of words (in the OCaml sense) reachable from the current promise. A promise keeps several pieces of information, such as its active children or associated resources. It can be interesting to monitor its memory usage.</p></div></div><h3 id="orphans"><a href="#orphans" class="anchor"></a>Daemon and orphan tasks.</h3><p>The prerogative of absolutely awaiting all of its direct children limits the user to considering certain anti-patterns. The best known is the <i>background</i> task: it consists of running a task that we would like to <i>detach</i> from the main task so that it can continue its life in autonomy. For OCaml/<code>lwt</code> aficionados, this corresponds to <code>Lwt.async</code>:</p><pre class="language-ocaml"><code>val detach : (unit -&gt; unit t) -&gt; unit</code></pre><p>Not that we want to impose an authoritarian family approach between parent and children, but the fact remains that these <i>orphaned</i> tasks have resources that we need to manage and free-up (even in an abnormal situation). We consider detachment to be an <i>anti-pattern</i>, since it requires the developer to take particular care (compared to other promises) not to 'forget' resources that could lead to memory leaks.</p><p>Instead of letting the developer commit to using a function that might be problematic, Miou offers a completely different interface that consists of assisting the developer in a coherent (and consistent) approach to responding to a particular design that is not all that systematic.</p><p>So a promise can be associated with an <a href="#type-orphans"><code>orphans</code></a>. The latter will then collect the results of the associated promise tasks and give you back the promises (via <a href="#val-care"><code>care</code></a>) in a 'non-blocking' mode: applying <a href="#val-await"><code>await</code></a> to them will give you the results directly.</p><p>In this way, by creating promises associated with this <a href="#type-orphans"><code>orphans</code></a> value, we can at the same time &quot;clean up&quot; these <i>background</i> tasks, as this code shows:</p><pre class="language-ocaml"><code>let rec clean_up orphans =
  match Miou.care orphans with
  | None -&gt; ()
  | Some prm -&gt; Miou.await_exn prm; clean_up orphans

let rec server orphans =
  clean_up orphans;
  ignore (Miou.call ~orphans handler);
  server orphans

let () = Miou.run @@ fun () -&gt; server (Miou.orphans ())</code></pre><p>There is a step-by-step <a href="../echo.html" title="echo">tutorial</a> on how to create an echo server and how to create a <i>daemon</i> with Miou.</p><div class="odoc-spec"><div class="spec type anchored" id="type-orphans"><a href="#type-orphans" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a orphans</span></span></code></div><div class="spec-doc"><p>The type of orphan collectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-orphans"><a href="#val-orphans" class="anchor"></a><code><span><span class="keyword">val</span> orphans : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span></span></code></div><div class="spec-doc"><p><code>orphans ()</code> makes a new orphan collectors which can used by <a href="#val-call"><code>call</code></a> and <a href="#val-call_cc"><code>call_cc</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : <span><span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span> option</span></span></code></div><div class="spec-doc"><p><code>care orphans</code> returns a <i>ready-to-await</i> promise or <code>Some None</code>. The user must <i>consume</i> the result of the promise with <a href="#val-await"><code>await</code></a>. Otherwise, Miou will raises the uncatchable <code>Still_has_children</code> exception. If <code>care</code> returns <code>None</code>, no children left behind, you can forget the <a href="#type-orphans"><code>orphans</code></a> value safely.</p></div></div><h3 id="launch-a-promise."><a href="#launch-a-promise." class="anchor"></a>Launch a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-call_cc"><a href="#val-call_cc" class="anchor"></a><code><span><span class="keyword">val</span> call_cc : 
  <span><span class="optlabel">?orphans</span>:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?give</span>:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call_cc fn</code> (for Call with Current Continuation) returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be carried out <b>concurrently</b> with the other tasks in the current domain.</p><p><b>NOTE</b>: About property and argument <code>give</code>, property deeds are copied and shared between the task initially in possession and the new task. In other words, both must <a href="Ownership/index.html#val-disown"><code>Ownership.disown</code></a> before termination. For the example, this code doesn't work because the main task (<a href="#val-run"><code>run</code></a>) hasn't <a href="Ownership/index.html#val-disown"><code>Ownership.disown</code></a> the resource.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let r = Miou.Ownership.own ~finally:Fun.id () in
  let p = Miou.call ~give:[ r ] @@ fun () -&gt; Miou.Ownership.disown r in
  Miou.await_exn p;;
Exception: Miou.Resource_leak.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call"><a href="#val-call" class="anchor"></a><code><span><span class="keyword">val</span> call : 
  <span><span class="optlabel">?orphans</span>:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?give</span>:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call fn</code> returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be run in parallel: the domain used to run the task is different from the domain with the promise. This assertion is always true:</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let p = Miou.call @@ fun () -&gt;
    let u = Miou.Domain.self () in
    let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
    (u, Miou.await_exn q) in
  let u, v = Miou.await_exn p in
  assert (v &lt;&gt; u) ;;</code></pre><p>Sequential calls to <a href="#val-call"><code>call</code></a> do not guarantee that different domains are always chosen. This code <b>may</b> be true.</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let p = Miou.call @@ fun () -&gt; Miou.Domain.self () in
  let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
  let u = Miou.await_exn p in
  let v = Miou.await_exn q in
  assert (u = v);</code></pre><p>To ensure that tasks are properly allocated to all domains, you need to use <a href="#val-parallel"><code>parallel</code></a>.</p><p><b>NOTE</b>: <a href="#val-call"><code>call</code></a> will never run a task on <i>dom0</i> (the main domain). Only the other domains can manage tasks in parallel.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-No_domain_available"><code>No_domain_available</code></a> <p>if no domain is available to execute the task in parallel or if the function is executed by the only domain available in parallel (it is impossible to assign a task to <code>dom0</code> from the other domains).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parallel"><a href="#val-parallel" class="anchor"></a><code><span><span class="keyword">val</span> parallel : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span></span></code></div><div class="spec-doc"><p><code>parallel fn lst</code> is the <i>fork-join</i> model: it is a way of setting up and executing parallel tasks, such that execution branches off in parallel at designated points in the program, to &quot;join&quot; (merge) at a subsequent point and resume sequential execution.</p><p>Let's take the example of a sequential merge-sort:</p><pre class="language-ocaml"><code>let sort ~compare (arr, lo, hi) =
  if hi - lo &gt;= 2 then begin
    let mi = (lo + hi) / 2 in
    sort ~compare (arr, lo, mi);
    sort ~compare (arr, mi, hi);
    merge ~compare arr lo mi hi
  end</code></pre><p>The 2 recursions work on 2 different spaces (from <code>lo</code> to <code>mi</code> and from <code>mi</code> to <code>hi</code>). We could parallelize their work such that:</p><pre class="language-ocaml"><code>let sort ~compare (arr, lo, hi) =
  if hi - lo &gt;= 2 then begin
    let mi = (lo + hi) / 2 in
    ignore (Miou.parallel (sort ~compare)
      [ (arr, lo, mi); (arr, mi, hi) ]);
    merge ~compare arr lo mi hi
  end</code></pre><p>Note that <a href="#val-parallel"><code>parallel</code></a> launches tasks (<i>fork</i>) and awaits for them (<i>join</i>). Conceptually, this corresponds to a <a href="#val-call"><code>call</code></a> on each elements of the given list and a <a href="#val-await_all"><code>await_all</code></a> on all of them, with tasks allocated equally to the domains.</p><p><b>NOTE</b>: This function will never assign a task to <i>dom0</i> - only the other domains can run tasks in parallel. To involve <code>dom0</code>, it simply has to be the one that launches the parallelization and performs the same task concurrently.</p><pre class="language-ocaml"><code>val server : unit -&gt; unit

let () = Miou.run @@ fun () -&gt;
  let p = Miou.call_cc server in
  Miou.parallel server (List.init (Miou.Domain.count ()) (Fun.const ())
  |&gt; List.iter (function Ok () -&gt; () | Error exn -&gt; raise exn);
  Miou.await_exn p</code></pre></div></div><h3 id="system"><a href="#system" class="anchor"></a>System events.</h3><p>Miou does not monitor system events. We arbitrarily leave this event monitoring to the user (so that Miou only requires OCaml to run). The advantage is that you can inject an event monitor from a specific system (such as a unikernel) if you want. However, <a href="../Miou_unix/index.html"><code>Miou_unix</code></a> is available if you want to do input/output.</p><p>To facilitate the integration of an event monitor, Miou offers an API for creating &quot;suspension points&quot; (see <a href="#val-suspend"><code>suspend</code></a>). In other words, points where execution will be blocked for as long as you wish. These points can be unblocked as soon as the monitor gives Miou a &quot;continuation&quot; to these points with <a href="#val-continue_with"><code>continue_with</code></a>.</p><p>The user must specify a <a href="#type-select"><code>select</code></a> function (via the <a href="#val-run"><code>run</code></a> function and the <a href="#type-events"><code>events</code></a> type), which must correspond to system event monitoring (probably using <code>Unix.select</code>). From these events, the monitor can decide which suspension point (thanks to its <a href="#type-uid"><code>uid</code></a>) should be released. Miou will then call this function for each <i>quanta</i> consumed. This gives Miou a high degree of availability to consume and process system events.</p><h4 id="domains,-suspension-and-monitoring."><a href="#domains,-suspension-and-monitoring." class="anchor"></a>Domains, suspension and monitoring.</h4><p>Each domain has its own monitor so that the suspension and its continuation given by the monitor is always local to the domain (the domain managing the suspension is the only one allowed to execute the continuation). One <a href="#type-events"><code>events</code></a> is allocated per domain - it is given on which domain the <code>event</code> value is assigned. In this way, the values (such as a table of active file-descriptors) required to monitor system events need <b>not</b> be <i>thread-safe</i>.</p><h4 id="sleep-state."><a href="#sleep-state." class="anchor"></a>Sleep state.</h4><p>Sometimes, Miou only has suspension points. In other words, only system events are required to execute tasks (typically waiting for a TCP/IP connection). We say we're in a sleep state. In this case, Miou informs the monitor <code>select</code> that it can wait indefinitely (with <code>poll:true</code>).</p><h4 id="cancellation."><a href="#cancellation." class="anchor"></a>Cancellation.</h4><p>It can happen that a task executed by one domain is cancelled by another domain (if the first was created by <a href="#val-call"><code>call</code></a>). This cancellation of a task can also mean the cancellation of existing suspension points into the task. Miou must therefore be able to <i>interrupt</i> a domain (especially if the latter is in a sleep state).</p><p>Thus, the user must have a mechanism for stopping event monitoring, which must be given to Miou via the <code>interrupt</code> field (see <a href="#type-events"><code>events</code></a>).</p><p>Finally, Miou informs the monitor of any points that have been cancelled, so that the associated events can no longer be monitored (this could involve cleaning up the table of active file-descritpors).</p><h4 id="tutorial."><a href="#tutorial." class="anchor"></a>Tutorial.</h4><p>To help you understand all these related elements, the distribution offers a short tutorial on how to implement functions that can block a given time (such as <code>Unix.sleep</code>): <a href="../sleepers.html"><code>sleepers</code></a>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-syscall"><a href="#type-syscall" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a syscall</span></span></code></div><div class="spec-doc"><p>The type of <i>syscalls</i>.</p><p>A syscall is an unique ID and function executed as soon as the suspension point is released. This suspension point is created using the <a href="#val-suspend"><code>suspend</code></a> function. <code>'a</code> corresponds to the type returned by the function (when the suspension point is released by the monitor).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-uid"><a href="#type-uid" class="anchor"></a><code><span><span class="keyword">type</span> uid</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>The type of unique IDs of <a href="#type-syscall"><code>syscall</code></a>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span></span></code></div><div class="spec-doc"><p><code>make return</code> creates a <i>syscall</i> which permits the user to create a new suspension point via <a href="#val-suspend"><code>suspend</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span><span class="keyword">val</span> suspend : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>suspend syscall</code> creates an user's defined suspension point. Miou will keep it internally and only the user is able to <i>continue</i> it via <a href="#type-events"><code>events</code></a> (and the <code>select</code> field) and a <a href="#type-continue"><code>continue</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid"><a href="#val-uid" class="anchor"></a><code><span><span class="keyword">val</span> uid : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-uid">uid</a></span></code></div><div class="spec-doc"><p><code>uid syscall</code> returns the unique ID of the syscall.</p><p><b>NOTE</b>: Uniqueness is local to the domain! This means that 2 domains can produce the same <a href="#type-uid"><code>uid</code></a>:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p () =
    let s0 = Miou.make (Fun.const ()) in
    let s1 = Miou.make (Fun.const ()) in
    assert (Miou.uid s0 &lt;&gt; Miou.uid s1);
    Miou.uid s0 in
  Miou.parallel p (List.init 2 (Fun.const ()))
  |&gt; function
  | [ Ok p0s; Ok p1s ] -&gt; assert (p0s = p1s)
  | _ -&gt; assert false 
;;
- : unit = ()</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-continue"><a href="#type-continue" class="anchor"></a><code><span><span class="keyword">type</span> continue</span></code></div><div class="spec-doc"><p>The type of continuations.</p><p>A continuation is a syscall that has been suspended (with <a href="#val-suspend"><code>suspend</code></a>) as well as a <i>pre</i> function. This is a value that must be given to Miou (via <code>select</code>) in order to <i>unblock</i> the previously created suspend point.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-continue_with"><a href="#val-continue_with" class="anchor"></a><code><span><span class="keyword">val</span> continue_with : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-continue">continue</a></span></code></div><div class="spec-doc"><p><code>continue_with syscall fn</code> creates a <a href="#type-continue"><code>continue</code></a> value which can be used by Miou to unblock the suspension point associated with the given syscall. The given function <code>fn</code> is pre-processed before Miou executes the <code>syscall</code>'s function. Any exception raised by the pre-processing function or the <code>syscall</code>'s function discontinues the suspension point with that exception.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-select"><a href="#type-select" class="anchor"></a><code><span><span class="keyword">type</span> select</span><span> = <span><span class="label">poll</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-uid">uid</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-continue">continue</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-events"><a href="#type-events" class="anchor"></a><code><span><span class="keyword">type</span> events</span><span> = </span><span>{</span></code><ol><li id="type-events.select" class="def record field anchored"><a href="#type-events.select" class="anchor"></a><code><span>select : <a href="#type-select">select</a>;</span></code></li><li id="type-events.interrupt" class="def record field anchored"><a href="#type-events.interrupt" class="anchor"></a><code><span>interrupt : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_pending"><a href="#val-is_pending" class="anchor"></a><code><span><span class="keyword">val</span> is_pending : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_pending syscall</code> checks the status of the <code>syscall</code>'s suspension point. A suspension point can be indirectly cancelled (if the user <a href="#val-cancel"><code>cancel</code></a>s the task with the suspension point). The user, in the <code>events.select</code> function (and <b>only</b> in this function) can check the status of a suspension point. If <a href="#val-is_pending"><code>is_pending</code></a> returns <code>true</code>, then the suspension point still exists and the user should give us a function to continue, otherwise the user can 'forget' the suspension point safely.</p><p><b>NOTE</b>: this function can only be executed in the <code>events.select</code> function. If the user calls it elsewhere, an exception will be raised by Miou.</p></div></div><h3 id="await-a-promise."><a href="#await-a-promise." class="anchor"></a>Await a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await prm</code> awaits for the task associated with the promise to finish. You can assume that after <a href="#val-await"><code>await</code></a>, the task has ended with an exception with the <code>Error</code> case or normally with the <code>Ok</code> case. In the case of an abnormal termination (the raising of an exception), the children of the promise are cancelled. For instance, this code is valid:</p><pre class="language-ocaml"><code># Miou_unix.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt;
    let child_of_p = Miou.call_cc @@ fun () -&gt; Miou_unix.sleep 10. in
    failwith &quot;p&quot;;
    Miou.await_exn child_of_p in
  Miou.await p ;;
- (unit, exn) result = Error (Failure &quot;p&quot;)
# (* [child_of_p] was cancelled and you don't await 10s. *)</code></pre><p>Note that you should <b>always</b> await for your children (it's illegal to forget your children), as in the example above (even if an exception occurs). If a task does not await for its children, an <i>uncatchable</i> exception is raised by Miou:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  ignore (Miou.call_cc (Fun.const ())) ;;
Exception: Miou.Still_has_children.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_exn"><a href="#val-await_exn" class="anchor"></a><code><span><span class="keyword">val</span> await_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_exn prm</code> is an alias for <a href="#val-await"><code>await</code></a> which reraises the exception in the <code>Error</code> case.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_all"><a href="#val-await_all" class="anchor"></a><code><span><span class="keyword">val</span> await_all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span></span></code></div><div class="spec-doc"><p><code>await_all prms</code> awaits for all the tasks linked to the promises given. If one of the tasks raises an <i>uncatchable</i> exception, <a href="#val-await_all"><code>await_all</code></a> reraises the said exception. All tasks are awaited for, regardless of whether any fail.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_first"><a href="#val-await_first" class="anchor"></a><code><span><span class="keyword">val</span> await_first : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await_first prms</code> awaits for a task to finish (by exception or normally) and cancels all the others. If several tasks finish &quot;at the same time&quot;, normally completed tasks are preferred to failed ones. This function can be useful for timeouts:</p><pre class="language-ocaml"><code># exception Timeout ;;
# Miou_unix.run @@ fun () -&gt;
  let p0 = Miou.call_cc (Fun.const ()) in
  let p1 = Miou.call_cc @@ fun () -&gt; Miou_unix.sleep 2.; raise Timeout in
  Miou.await_first [ p0; p1 ] ;;
- : (unit, exn) result = Ok ()</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the promise list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_one"><a href="#val-await_one" class="anchor"></a><code><span><span class="keyword">val</span> await_one : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await_one prms</code> awaits for a task to finish (by exception or normally). Despite <a href="#val-await_first"><code>await_first</code></a>, <a href="#val-await_one"><code>await_one</code></a> does <b>not</b> cancel all the others. The user must <a href="#val-await"><code>await</code></a> them, otherwise Miou will assume they're still active and will raise <code>Still_has_children</code>.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  Miou.await_one
    [ Miou.call_cc (Fun.const 1)
    ; Miou.call_cc (Fun.const 2) ] ;;
Exception: Miou.Still_has_children</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the promise list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-both"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> * <span><span>(<span class="type-var">'b</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>both prm0 prm1</code> awaits <code>prm0</code> <b>and</b>) <code>prm1</code>. It's equivalent to:</p><pre class="language-ocaml"><code>let both prm0 prm1 =
  let a = Miou.await prm0 in
  let b = Miou.await prm1 in
  (a, b)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> reschedules tasks and give an opportunity to carry out the tasks that have been on hold the longest. For intance:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Hello&quot; in
  print_endline &quot;World&quot;;
  Miou.await_exn p ;;
World
Hello
- : unit = ()
# Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Hello&quot; in
  Miou.yield ();
  print_endline &quot;World&quot;;
  Miou.await_exn p
Hello
World
- : unit = ()</code></pre></div></div><h3 id="cancellation._2"><a href="#cancellation._2" class="anchor"></a>Cancellation.</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cancelled"><a href="#exception-Cancelled" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cancelled</span></span></code></div><div class="spec-doc"><p>Used when a task is cancelled by <a href="#val-cancel"><code>cancel</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel prm</code> <i>asynchronously</i> cancels the given promise <code>prm</code>. Miou allows the forgetting of a cancelled promise and the forgetting of its children. For instance, this code is valid (despite the second one):</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  ignore (Miou.cancel (Miou.call (Fun.const ()))) ;;
- : unit = ()
# Miou.run @@ fun () -&gt;
  ignore (Miou.call (Fun.const ())) ;;
Exception: Miou.Still_has_children</code></pre><p>Cancellation terminates all the children. After the cancellation, the promise and its children all stopped. Resolved children are also cancelled (their results are erased). Canceling a task that has already been solved changes the state of the task to abnormal termination <code>Error Cancelled</code>.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (Fun.const ()) in
  Miou.await_exn p;
  Miou.cancel p;
  Miou.await_exn p ;;
Exception: Miou.Cancelled.</code></pre><p>This case shows that, even if the task has been resolved internally, the cancellation also applies.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Resolved!&quot; in
  Miou.yield ();
  Miou.cancel p;
  Miou.await_exn p ;;
Resolved!
Exception: Miou.Cancelled.</code></pre><p>Only the creator of a task can <a href="#val-cancel"><code>cancel</code></a> it (the relationship also applies to cancellation, otherwise Miou raises the exception <code>Not_a_child</code>).</p><p><b>NOTE</b>: Cancellation <i>asynchronicity</i> means that other concurrent tasks can run while the cancellation is in progress. In fact, in the case of an cancellation of a parallel task (see <a href="#val-call"><code>call</code></a>), the cancellation may take a certain amount of time (the time it takes for the domains to synchronise) which should not affect the opportunity for other concurrent tasks to run.</p></div></div><h3 id="composition."><a href="#composition." class="anchor"></a>Composition.</h3><p>It is possible to compose Miou with a library that also generates effects. The user can compose in 2 ways:</p><ul><li>simply apply his/her effect manager with its function in Miou <code>Miou.call{,_cc} @@ fun () -&gt; handler fn ()</code></li><li>inform Miou of an effect handler that should comply with the <b><i>quanta</i> rule</b></li></ul><p>Remember that Miou suspends a task as soon as it emits an effect. The second case can be interesting in order to always ensure the availability of the application regardless effect handlers. Here's a basic example of how to compose.</p><pre class="language-ocaml"><code>type _ Effect.t += Foo : unit Effect.t

let handler fn v =
  let open Effect.Deep in
  let retc = Fun.id and exnc = raise in
  let effc : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'b) option =
    function Foo -&gt; Some (fun k -&gt; continue k ())
           | _ -&gt; None in
  match_with fn v { retc; exnc; effc; }

let () = Miou.run ~handler:{ Miou.handler } @@ fun () -&gt;
  let prm = Miou.call @@ fun () -&gt; Effect.perform Foo in
  Miou.await_exn prm</code></pre><p>The user can also compose several effects managers:</p><pre class="language-ocaml"><code># let compose { Miou.handler= a } { Miou.handler= b } =
  { Miou.handler= fun fn v -&gt; (a (b fn)) v } ;;
val compose : Miou.handler -&gt; Miou.handler -&gt; Miou.handler = &lt;fun&gt;</code></pre><p><b>NOTE</b>: We want to reiterate that such a composition implies that the effect will not be executed <i>immediately</i>: the task will be suspended and the effect will be produced only as soon as the said task has its execution slot. One type of composition therefore becomes impossible if we want the production of an effect to produce an immediate action.</p><p>The example below shows that <code>Effect.perform</code> suspends and gives <code>_p</code> the opportunity to execute its task <b>before</b> the <code>Unhandled</code> exception is raised.</p><pre class="language-ocaml"><code># try
    Miou.run @@ fun () -&gt;
    let _p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Hello&quot; in
    Effect.perform Foo
  with Stdlib.Effect.Unhandled Foo -&gt; print_endline &quot;World&quot;
;;
Hello
World
- : unit = ()</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-handler"><a href="#type-handler" class="anchor"></a><code><span><span class="keyword">type</span> handler</span><span> = </span><span>{</span></code><ol><li id="type-handler.handler" class="def record field anchored"><a href="#type-handler.handler" class="anchor"></a><code><span>handler : 'a 'b. <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-No_domain_available"><a href="#exception-No_domain_available" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_domain_available</span></span></code></div><div class="spec-doc"><p>An exception which can be raised by <a href="#val-call"><code>call</code></a> if no domain is available to execute the task in parallel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?quanta</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?events</span>:<span>(<span><a href="Domain/Uid/index.html#type-t">Domain.Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-events">events</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?g</span>:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?domains</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?handler</span>:<a href="#type-handler">handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div></div></body></html>
