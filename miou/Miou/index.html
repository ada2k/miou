<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Miou (miou.Miou)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">miou</a> &#x00BB; Miou</nav><header class="odoc-preamble"><h1>Module <code><span>Miou</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#miou,-a-simple-scheduler-for-ocaml-5.">Miou, a simple scheduler for OCaml 5.</a><ul><li><a href="#definitions-of-terms.">Definitions of terms.</a><ul><li><a href="#a-task.">A task.</a></li><li><a href="#suspension.">Suspension.</a></li><li><a href="#quanta">A quanta.</a></li><li><a href="#concurrency.">Concurrency.</a></li><li><a href="#parallelism.">Parallelism.</a><ul><li><a href="#domains.">Domains.</a></li></ul></li><li><a href="#synchronisation-points.">Synchronisation points.</a></li><li><a href="#system-events.">System events.</a></li></ul></li><li><a href="#the-&quot;round-robin&quot;-scheduler.">The &quot;round-robin&quot; scheduler.</a><ul><li><a href="#availability.">Availability.</a></li><li><a href="#time-wasted.">Time wasted.</a></li><li><a href="#the-famine-problem.">The famine problem.</a></li><li><a href="#tuning.">Tuning.</a></li></ul></li><li><a href="#rules">Rules</a><ul><li><a href="#rule-1,-wait-for-all-your-tasks.">Rule 1, wait for all your tasks.</a></li><li><a href="#rule-2,-only-wait-for-direct-children.">Rule 2, only wait for direct children.</a></li><li><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled.">Rule 3, a task can only be awaited or cancelled.</a></li><li><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished.">Rule 4, a task only finishes after its children have finished.</a></li></ul></li><li><a href="#orphans">Daemon and orphan tasks.</a></li><li><a href="#launch-a-promise.">Launch a promise.</a></li><li><a href="#system-events._2">System events.</a></li><li><a href="#await-a-promise.">Await a promise.</a></li><li><a href="#cancellation.">Cancellation.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="miou,-a-simple-scheduler-for-ocaml-5."><a href="#miou,-a-simple-scheduler-for-ocaml-5." class="anchor"></a>Miou, a simple scheduler for OCaml 5.</h2><p>Miou is a simple scheduler for OCaml 5. The purpose of this library is to provide an interface for launching tasks concurrently and/or in parallel with others. Miou proposes a minimal, homogeneous, simple and conservative interface.</p><p>This presentation will allow us to introduce several concepts and what Miou can offer.</p><h3 id="definitions-of-terms."><a href="#definitions-of-terms." class="anchor"></a>Definitions of terms.</h3><h4 id="a-task."><a href="#a-task." class="anchor"></a>A task.</h4><p>A task is a function on which several operations required by Miou exist:</p><ol><li>a task can be launched/executed</li><li>a task can be stopped (suspended)</li><li>stopping a task produces a state of the task</li><li>a task can be restarted from its state</li></ol><p>The <a href="State/index.html"><code>State</code></a> module offers a more concrete definition of these operations with what the OCaml 5 <code>Effect</code> module offers. Suspension is the fundamental operation in the implementation of a scheduleur. We have therefore chosen to be able to suspend a task as soon as it emits an effect.</p><p>This is perhaps the most important thing to remember about this definition: a task is suspended as soon as it emits <b>one</b> effect.</p><h4 id="suspension."><a href="#suspension." class="anchor"></a>Suspension.</h4><p>Suspension consists of obtaining a <i>state</i> for the task which we can be &quot;stored&quot; and which allows us to <i>continue</i> the task. The task has stopped at a specific point and its state consists roughly of:</p><ul><li>the point where the task stopped</li><li>a particular state of the memory required to perform the task</li><li>and the disruptive element of the suspension: the effect.</li></ul><p>From this state, Miou can continue or <i>discontinue</i> the task. Continuing the task consists of restarting the execution of the task from its stopping point. Discontinuing a task consists of not restarting the task and transitioning the state of the task to an error (in this case, the raising of an exception).</p><h4 id="quanta"><a href="#quanta" class="anchor"></a>A quanta.</h4><p>A <i>quanta</i> is a measure used to limit the execution of a task. Usually, the <i>quanta</i> used is time: you limit the execution time of a task to 100ms, for example, and then suspend the task and execute another one.</p><p>As far as Miou is concerned, the <i>quanta</i> used is the production of effects. For more details on the reasons for this, please refer to the <a href="State/index.html"><code>State</code></a> module. The user can modify the number of <i>quantas</i> allocated to tasks. By default, Miou only allocates one <i>quanta</i> per task so that they can be reordered later. However, it may be appropriate for a task to consume a maximum of 10, 20 or 1000 <i>quantas</i>.</p><h4 id="concurrency."><a href="#concurrency." class="anchor"></a>Concurrency.</h4><p>Concurrency consists of swapping the execution of several tasks on the same core. The aim of the scheduler is to have several tasks, some of which depend on the result of others, and to schedule these tasks in a certain execution order in order to obtain the final result.</p><p>It is important to note that, in the context of concurrency, tasks have exclusive access to memory as only one core is able to execute them: there cannot be 2 tasks executing at the same time. However, the order in which the tasks are executed is decided by the scheduler.</p><p>The policy of concurrency can be to &quot;prioritise&quot; some tasks so that other tasks, which depend on the result of the first tasks, can be unblocked. In our case, Miou does <b>not</b> prioritise tasks but has a re-scheduling and execution policy which ensures that all tasks have the same opportunity to be executed (and that those producing a result needed by others can be executed just as well as the others).</p><p>The user can launch a concurrently-running task using <a href="#val-call_cc"><code>call_cc</code></a>. The function returns <i>a promise</i> (<a href="#type-t"><code>t</code></a>), <i>a witness</i> to the execution of the task. This witness can be used to obtain the result of the task:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let promise = Miou.call_cc @@ fun () -&gt; 21 + 21 in
  Miou.await_exn promise ;;
- : int = 42</code></pre><h4 id="parallelism."><a href="#parallelism." class="anchor"></a>Parallelism.</h4><p>Since OCaml 5, it has been possible to run functions in parallel. In other words, they can run &quot;at the same time&quot; using several cores. The advantage of parallelism is that execution time can be shared between several cores. For example, if 2 tasks require 100ms to calculate a result, in a concurrent context we would need 200ms to complete these tasks, whereas we would only need 2 cores and 100ms to complete them in parallel.</p><p>Earlier, we mentioned exclusive access to memory by tasks if they are concurrent. Unfortunately, this is no longer true in parallel. If you want to keep this property for certain values, you should use the <code>Atomic</code> module.</p><p>The user can launch tasks in parallel using <a href="#val-call"><code>call</code></a>. Note that the <i>witness</i> for the parallel task (the promise <a href="#type-t"><code>t</code></a>) is of the same type as that produced by <a href="#val-call_cc"><code>call_cc</code></a>.</p><p>We recommend that you let Miou decide how many domains to allocate.</p><h5 id="domains."><a href="#domains." class="anchor"></a>Domains.</h5><p>Miou is able to use several cores and thus launch tasks in parallel because it is able to create <code>Domain</code>.t. However, the number of domains is <b>limited</b>: it is counter-productive to launch 10 domains when we only have (physically) 4 cores, for example.</p><p>Miou also differentiates between <code>dom0</code> (the main domain that runs your program) and the other domains. The main difference is that <a href="#val-call"><code>call</code></a> (or <a href="#val-parallel"><code>parallel</code></a>) will <b>never</b> assign a new task in parallel to <code>dom0</code>.</p><h4 id="synchronisation-points."><a href="#synchronisation-points." class="anchor"></a>Synchronisation points.</h4><p>We mentioned earlier that some tasks can &quot;wait&quot; for the results of other tasks. We call these &quot;synchronisation points&quot;. Since tasks can run concurrently and/or in parallel, Miou offers functions where a particular state of the tasks (the termination state) is expected.</p><p>Miou will then be in a waiting state (it will simply observe the state of the said task until this state has changed):</p><ul><li>while waiting for a concurrent task, Miou will then re-schedule and execute other tasks in order to &quot;unblock&quot; the first one</li><li>while waiting for a task to run in parallel, Miou will suggest that other tasks assigned to the same domain can run while the first one continues to run (on another domain) and return to a waiting state until the task in question has finished.</li></ul><p>It may be possible to wait for one (<a href="#val-await"><code>await</code></a>) or more tasks (<a href="#val-await_all"><code>await_all</code></a>) using their promises. It is also possible to wait for one of the available tasks (<a href="#val-await_first"><code>await_first</code></a> or <a href="#val-await_one"><code>await_one</code></a>). The result of the first task to finish will be given when it is used.</p><h4 id="system-events."><a href="#system-events." class="anchor"></a>System events.</h4><p>Another waiting state exists: waiting for a system event, such as waiting for a TCP/IP connection to arrive. Miou provides the ability for users to implement these system event synchronisation points themselves. We recommend reading the implementation of <a href="../sleepers.html"><code>sleepers</code></a> with Miou to find out more about this.</p><p><a href="../Miou_unix/index.html"><code>Miou_unix</code></a> implements some of these points, such as waiting to receive information (<code>read</code>) or waiting to be able to write information (<code>write</code>), as well as other system events.</p><p>What makes these points of synchronisation of system events different from waiting for the result of a <i>pure</i> task (which does not interact with the system) is that we cannot calculate the <i>waiting time</i>. We can wait a few milliseconds or 1 hour for the arrival of a TCP/IP connection, for example.</p><p>This makes it difficult to prioritise tasks in relation to each other, as we lack too much information to find the optimum order for executing tasks. Once again, Miou doesn't prioritise tasks.</p><h3 id="the-&quot;round-robin&quot;-scheduler."><a href="#the-&quot;round-robin&quot;-scheduler." class="anchor"></a>The &quot;round-robin&quot; scheduler.</h3><p>Miou implements what is known as a round-robin scheduler. This is a scheduler with very simple rules:</p><ol><li>if a task arrives, execute it up to a certain <i>quanta</i></li><li>if the task has finished, give the result</li><li>if not, re-order the task at the end of the to-do list</li><li>take the next task and repeat the operation.</li></ol><p>The special feature of a round-robin scheduler is that it does not prioritise tasks according to their status. It simply allocates <b>a fair</b> amount of time/<i>quanta</i> of domain usage to all tasks (a bit like communism).</p><p>So, by default, Miou suggests that a task can only emit one and only one effect, which is our <a href="#quanta">A quanta.</a>. Most of the functions proposed by Miou produce an effect. Miou then reorders the task at the end of the to-do list and repeats the operation.</p><h4 id="availability."><a href="#availability." class="anchor"></a>Availability.</h4><p>The advantage of this type of task management policy is that it increases the availability of tasks. For example, 2 tasks waiting for 2 system events (the reception of a TCP/IP packet and the waiting for a new TCP/IP connection) will have the same execution time allocated to them.</p><p>This availability means that Miou is more <i>in-sync</i> with system events. In fact, the system keeps these events until the application space requests them (with <code>select()</code>) and consumes them (<code>read()</code>, <code>accept()</code>, etc.). Miou's objective is to ensure that several tasks (dependent on these events) can all respond to the consumption of these events from the system, without one of them being able to have exclusive execution time on a domain.</p><p>In this way, a Miou application can respond to the consumption of a <code>read()</code> and an <code>accept()</code> without one of these tasks blocking the other - even though the two correspond to completely different execution paths. Finally, a Miou application <b>is</b> available from a system and network point of view.</p><h4 id="time-wasted."><a href="#time-wasted." class="anchor"></a>Time wasted.</h4><p>The disadvantage of such a policy is the execution of pending tasks. This is because Miou does not discriminate between tasks: it does not prioritise tasks that can do something over those that are waiting.</p><p>So it could happen that Miou &quot;wastes&quot; its time trying to execute pending tasks for 1 <i>quanta</i> and that the result of this execution comes to nothing (because the result is not yet available).</p><p>This non-discriminatory approach is important because if we consider waiting for system events, it becomes difficult to prioritise tasks fairly since, by definition, system events can occur at any time. Miou therefore responds to the availability of tasks to consume system events. It does not address the optimal scheduling of <i>pure</i> tasks.</p><h4 id="the-famine-problem."><a href="#the-famine-problem." class="anchor"></a>The famine problem.</h4><p>The prioritisation of tasks coupled with the limited use of domains can lead to a starvation problem. Indeed, through prioritisation, a task can be excluded from using one of the available domains - because it has been decided that other tasks have priority there. However, this excluded task may be necessary (and even central) to the completion of our program.</p><p>In this case, we talk about a starvation problem. The round-robin scheduler solves this problem by not discriminating between tasks and by allocating them a fair execution time on the domains. The round-robin scheduler is <i>starvation-free</i>. Even if it appears that Miou wasting time executing tasks that would not produce any results, the central task required to terminate our program would be invariably run in all cases.</p><h4 id="tuning."><a href="#tuning." class="anchor"></a>Tuning.</h4><p>It is possible to modify Miou's behaviour depending on the purpose of your program. Choosing to allow a task to emit only one effect can have serious implications for the application's performance. Miou therefore suggests that the user can decide how many <i>quantas</i> that tasks can consume.</p><p>In this case, for certain so-called <i>pure</i> applications, it can be interesting to increase this number. We recommend that you read the <a href="../merkle.html">merkle-tree</a> tutorial to understand all the subtleties.</p><h3 id="rules"><a href="#rules" class="anchor"></a>Rules</h3><p>Over and above its design, Miou imposes rules to assist the programmer in designing his/her application. These rules are explained here. If the developer does not respect these rules, Miou raises an <i>uncatchable</i> exception. In other words, an exception that the user has <b>not</b> the definition of and cannot ignore.</p><h4 id="rule-1,-wait-for-all-your-tasks."><a href="#rule-1,-wait-for-all-your-tasks." class="anchor"></a>Rule 1, wait for all your tasks.</h4><p>It is forbidden to forget your children. The creation of a task necessarily implies that the developer waits (<a href="#val-await"><code>await</code></a>) or cancels (<a href="#val-cancel"><code>cancel</code></a>) the task afterwards:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt; Miou.call_cc (Fun.const ()) ;;
Exception: Miou.Still_has_children.</code></pre><h4 id="rule-2,-only-wait-for-direct-children."><a href="#rule-2,-only-wait-for-direct-children." class="anchor"></a>Rule 2, only wait for direct children.</h4><p>You can only wait for your direct children. Transferring a promise to another task so that it can wait for it is illegal:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (Fun.const ()) in
  let q = Miou.call_cc (fun () -&gt; Miou.await_exn p) in
  Miou.await_all [ p; q ] |&gt; ignore
Exception: Miou.Not_a_child.</code></pre><h4 id="rule-3,-a-task-can-only-be-awaited-or-cancelled."><a href="#rule-3,-a-task-can-only-be-awaited-or-cancelled." class="anchor"></a>Rule 3, a task can only be awaited or cancelled.</h4><p>Miou only allows you to wait for or cancel a task. It is also impossible to detach a task. For more information on this subject, we recommend reading the <a href="#orphans">Daemon and orphan tasks.</a> section.</p><h4 id="rule-4,-a-task-only-finishes-after-its-children-have-finished."><a href="#rule-4,-a-task-only-finishes-after-its-children-have-finished." class="anchor"></a>Rule 4, a task only finishes after its children have finished.</h4><p>By extension, as soon as a task is finished, all its children are finished too. The same applies to cancellation. If you cancel a task, you also cancel its children.</p><div class="odoc-spec"><div class="spec module anchored" id="module-State"><a href="#module-State" class="anchor"></a><code><span><span class="keyword">module</span> <a href="State/index.html">State</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Queue/index.html">Queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ownership"><a href="#module-Ownership" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ownership/index.html">Ownership</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of promises.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Domain"><a href="#module-Domain" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Domain/index.html">Domain</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="orphans"><a href="#orphans" class="anchor"></a>Daemon and orphan tasks.</h3><p>The prerogative of absolutely awaiting all of its direct children limits the user to considering certain anti-patterns. The best known is the <i>background</i> task: it consists of running a task that we would like to <i>detach</i> from the main task so that it can continue its life in autonomy. For OCaml/<code>lwt</code> aficionados, this corresponds to <code>Lwt.async</code>:</p><pre class="language-ocaml"><code>val detach : (unit -&gt; unit t) -&gt; unit</code></pre><p>Not that we want to impose an authoritarian family approach between parent and children, but the fact remains that these <i>orphaned</i> tasks have resources that we need to manage and free-up (even in an abnormal situation). We consider detachment to be an <i>anti-pattern</i>, since it requires the developer to take particular care (compared to other promises) not to 'forget' resources that could lead to memory leaks.</p><p>Instead of letting the developer commit to using a function that might be problematic, Miou offers a completely different interface that consists of assisting the developer in a coherent (and consistent) approach to responding to a particular design that is not all that systematic.</p><p>So a promise can be associated with an <a href="#type-orphans"><code>orphans</code></a>. The latter will then collect the results of the associated promise tasks and give you back the promises (via <a href="#val-care"><code>care</code></a>) in a 'non-blocking' mode: applying <a href="#val-await"><code>await</code></a> to them will give you the results directly.</p><p>In this way, by creating promises associated with this <a href="#type-orphans"><code>orphans</code></a> value, we can at the same time &quot;clean up&quot; these <i>background</i> tasks, as this code shows:</p><pre class="language-ocaml"><code>let rec clean_up orphans =
  match Miou.care orphans with
  | None -&gt; ()
  | Some prm -&gt; Miou.await_exn prm; clean_up orphans

let rec server orphans =
  clean_up orphans;
  ignore (Miou.call ~orphans handler);
  server orphans

let () = Miou.run @@ fun () -&gt; server (Miou.orphans ())</code></pre><p>There is a step-by-step <span class="xref-unresolved">tutorial</span> on how to create an echo server and how to create a <i>daemon</i> with Miou.</p><div class="odoc-spec"><div class="spec type anchored" id="type-orphans"><a href="#type-orphans" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a orphans</span></span></code></div><div class="spec-doc"><p>The type of orphan collectors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-orphans"><a href="#val-orphans" class="anchor"></a><code><span><span class="keyword">val</span> orphans : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span></span></code></div><div class="spec-doc"><p><code>orphans ()</code> makes a new orphan collectors which can used by <a href="#val-call"><code>call</code></a> and <a href="#val-call_cc"><code>call_cc</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : <span><span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>care orphans</code> returns a <i>ready-to-await</i> promise or <code>None</code>. The user must <i>consume</i> the result of the promise with <a href="#val-await"><code>await</code></a>. Otherwise, Miou will raises the uncatchable <code>Still_has_children</code> exception.</p></div></div><h3 id="launch-a-promise."><a href="#launch-a-promise." class="anchor"></a>Launch a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-call_cc"><a href="#val-call_cc" class="anchor"></a><code><span><span class="keyword">val</span> call_cc : 
  <span>?orphans:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?give:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call_cc fn</code> (for Call with Current Continuation) returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be carried out <b>concurrently</b> with the other tasks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call"><a href="#val-call" class="anchor"></a><code><span><span class="keyword">val</span> call : 
  <span>?orphans:<span><span class="type-var">'a</span> <a href="#type-orphans">orphans</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?give:<span><a href="Ownership/index.html#type-t">Ownership.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>call fn</code> returns a promise <a href="#type-t"><code>t</code></a> representing the state of the task given as an argument. The task will be run in parallel: the domain used to run the task is different from the domain with the promise. This assertion is always true:</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let p = Miou.call @@ fun () -&gt;
    let u = Miou.Domain.self () in
    let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
    (u, Miou.await_exn q) in
  let u, v = Miou.await_exn p in
  assert (v &lt;&gt; u) ;;</code></pre><p>Sequential calls to <a href="#val-call"><code>call</code></a> do not guarantee that different domains are always chosen. This code <b>may</b> be true.</p><pre class="language-ocaml"><code>let () = Miou.run @@ fun () -&gt;
  let p = Miou.call @@ fun () -&gt; Miou.Domain.self () in
  let q = Miou.call @@ fun () -&gt; Miou.Domain.self () in
  let u = Miou.await_exn p in
  let v = Miou.await_exn q in
  assert (u = v);</code></pre><p>To ensure that tasks are properly allocated to all domains, you need to use <a href="#val-parallel"><code>parallel</code></a>.</p><p><b>NOTE</b>: <a href="#val-call"><code>call</code></a> will never run a task on <i>dom0</i> (the main domain). Only the other domains can manage tasks in parallel.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parallel"><a href="#val-parallel" class="anchor"></a><code><span><span class="keyword">val</span> parallel : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span></span></code></div><div class="spec-doc"><p><code>parallel fn lst</code> is the <i>fork-join</i> model: it is a way of setting up and executing parallel tasks, such that execution branches off in parallel at designated points in the program, to &quot;join&quot; (merge) at a subsequent point and resume sequential execution.</p><p>Let's take the example of a sequential merge-sort:</p><pre class="language-ocaml"><code>let sort ~compare (arr, lo, hi) =
  if hi - lo &gt;= 2 then begin
    let mi = (lo + hi) / 2 in
    sort ~compare (arr, lo, mi);
    sort ~compare (arr, mi, hi);
    merge ~compare arr lo mi hi
  end</code></pre><p>The 2 recursions work on 2 different spaces (from <code>lo</code> to <code>mi</code> and from <code>mi</code> to <code>hi</code>). We could parallelize their work such that:</p><pre class="language-ocaml"><code>let sort ~compare (arr, lo, hi) =
  if hi - lo &gt;= 2 then begin
    let mi = (lo + hi) / 2 in
    ignore (Miou.parallel (sort ~compare)
      [ (arr, lo, mi); (arr, mi, hi) ]);
    merge ~compare arr lo mi hi
  end</code></pre><p>Note that <a href="#val-parallel"><code>parallel</code></a> launches tasks (<i>fork</i>) and waits for them (<i>join</i>). Conceptually, this corresponds to a <a href="#val-call"><code>call</code></a> on each elements of the given list and a <a href="#val-await_all"><code>await_all</code></a> on all of them, with tasks allocated equally to the domains.</p><p><b>NOTE</b>: This function will never assign a task to <i>dom0</i> - only the other domains can run tasks in parallel.</p></div></div><h3 id="system-events._2"><a href="#system-events._2" class="anchor"></a>System events.</h3><p>Miou does not interact with the system, only with the OCaml runtime. As a result, it does not implement the usual input/output operations. Nevertheless, it offers a fairly simple API for using functions that interact with the system (and that can, above all, block).</p><p>One of the rules of Miou is never to give it blocking functions to eat (in fact, it has very strict - but very simple - nutritional contraints).</p><p>On the other hand, the system can inform you when a function is non-blocking (and can therefore be given to Miou). The idea is to inform Miou of the existence of a <i>suspension point</i>, which it will then be <i>continued</i>. Of course, it won't be able to, but as a last resort, Miou will come back to you to ask for a possible suspension point to continue. It will do this via an user's defined function, which you can specify using the <a href="#val-run"><code>run</code></a> function (see <code>events</code> argument).</p><p>This user's defined function return a <a href="#type-continue"><code>continue</code></a> which requires our <a href="#type-syscall"><code>syscall</code></a> (which made the suspension point) and a non-blocking function (<code>unit -&gt; unit</code>). With this value, Miou will be able to continue from our suspension point.</p><p>For more information on this API, a tutorial is available on how to implement <a href="../sleepers.html"><code>sleepers</code></a>: tasks that block your process for a time.</p><div class="odoc-spec"><div class="spec type anchored" id="type-syscall"><a href="#type-syscall" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a syscall</span></span></code></div><div class="spec-doc"><p>The type of <i>syscalls</i>.</p><p>A syscall is like an unique ID of a specific suspension point made by <a href="#val-suspend"><code>suspend</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-uid"><a href="#type-uid" class="anchor"></a><code><span><span class="keyword">type</span> uid</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>The type of unique IDs of <a href="#type-syscall"><code>syscall</code></a>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span></span></code></div><div class="spec-doc"><p><code>make return</code> creates a <i>syscall</i> which permits the user to create a new suspension point via <a href="#val-suspend"><code>suspend</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-suspend"><a href="#val-suspend" class="anchor"></a><code><span><span class="keyword">val</span> suspend : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>suspend syscall</code> creates an user's defined suspension point. Miou will keep it internally and only the user is able to <i>continue</i> it via <a href="#type-events"><code>events</code></a> and a <a href="#type-continue"><code>continue</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid"><a href="#val-uid" class="anchor"></a><code><span><span class="keyword">val</span> uid : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-uid">uid</a></span></code></div><div class="spec-doc"><p><code>uid syscall</code> returns the unique ID of the syscall.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-continue"><a href="#type-continue" class="anchor"></a><code><span><span class="keyword">type</span> continue</span></code></div><div class="spec-doc"><p>The type of continuations.</p><p>A continuation is a suspension point and a function which can &quot;unblock&quot; the suspension point.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-task"><a href="#val-task" class="anchor"></a><code><span><span class="keyword">val</span> task : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-continue">continue</a></span></code></div><div class="spec-doc"><p><code>task syscall fn</code> creates a <a href="#type-continue"><code>continue</code></a> value which can be used by Miou to unlock via the given <code>fn</code> the user's defined suspension point represented by the given <code>syscall</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-events"><a href="#type-events" class="anchor"></a><code><span><span class="keyword">type</span> events</span><span> = </span><span>{</span></code><ol><li id="type-events.select" class="def record field anchored"><a href="#type-events.select" class="anchor"></a><code><span>select : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-continue">continue</a> list</span>;</span></code></li><li id="type-events.interrupt" class="def record field anchored"><a href="#type-events.interrupt" class="anchor"></a><code><span>interrupt : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_pending"><a href="#val-is_pending" class="anchor"></a><code><span><span class="keyword">val</span> is_pending : <span><span><span class="type-var">'a</span> <a href="#type-syscall">syscall</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_pending syscall</code> checks the status of the suspension point. A suspension point can be indirectly cancelled (if the user <a href="#val-cancel"><code>cancel</code></a>s the task with the suspension point). The user, in the <code>events.select</code> function (and <b>only</b> in this function) can check the status of a suspension point. If <a href="#val-is_pending"><code>is_pending</code></a> returns <code>true</code>, then the suspension point still exists and the user should give us a function to continue, otherwise the user can 'forget' the suspension point safely.</p><p><b>NOTE</b>: this function can only be executed in the <code>events.select</code> function. If the user calls it elsewhere, an exception will be raised by Miou.</p></div></div><h3 id="await-a-promise."><a href="#await-a-promise." class="anchor"></a>Await a promise.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await prm</code> waits for the task associated with the promise to finish. You can assume that after <a href="#val-await"><code>await</code></a>, the task has ended with an exception with the <code>Error</code> case or normally with the <code>Ok</code> case. In the case of an abnormal termination (the raising of an exception), the children of the promise are cancelled. For instance, this code is valid:</p><pre class="language-ocaml"><code># Miouu.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt;
    let child_of_p = Miou.call_cc @@ fun () -&gt; Miouu.sleep 10. in
    failwith &quot;p&quot;;
    Miou.await_exn child_of_p in
  Miou.await p ;;
- (unit, exn) result = Error (Failure &quot;p&quot;)
# (* [child_of_p] was cancelled and you don't wait 10s. *)</code></pre><p>Note that you should <b>always</b> wait for your children (it's illegal to forget your children), as in the example above (even if an exception occurs). If a task does not wait for its children, an <i>uncatchable</i> exception is thrown by Miou:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  ignore (Miou.call_cc (Fun.const ())) ;;
Exception: Miou.Still_has_children.</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_exn"><a href="#val-await_exn" class="anchor"></a><code><span><span class="keyword">val</span> await_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_exn prm</code> is an alias for <a href="#val-await"><code>await</code></a> which reraises the exception in the <code>Error</code> case.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_all"><a href="#val-await_all" class="anchor"></a><code><span><span class="keyword">val</span> await_all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span></span></code></div><div class="spec-doc"><p><code>await_all prms</code> waits for all the tasks linked to the promises given. If one of the tasks raises an <i>uncatchable</i> exception, <a href="#val-await_all"><code>await_all</code></a> reraises the said exception. All tasks are waited for, regardless of whether any fail.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_first"><a href="#val-await_first" class="anchor"></a><code><span><span class="keyword">val</span> await_first : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await_first prms</code> waits for a task to finish (by exception or normally) and cancels all the others. If several tasks finish &quot;at the same time&quot;, one of them is chosen randomly. This function can be useful for timeouts:</p><pre class="language-ocaml"><code># exception Timeout ;;
# Miouu.run @@ fun () -&gt;
  let p0 = Miou.call_cc (Fun.const ()) in
  let p1 = Miou.call_cc @@ fun () -&gt; Miouu.sleep 2.; raise Timeout in
  Miou.await_first [ p0; p1 ] ;;
- : (unit, exn) result = Ok ()</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_one"><a href="#val-await_one" class="anchor"></a><code><span><span class="keyword">val</span> await_one : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, exn)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>await_one prms</code> waits for a task to finish (by exception or normally). Despite <a href="#val-await_first"><code>await_first</code></a>, <a href="#val-await_one"><code>await_one</code></a> does <b>not</b> cancel all the others. The user must <a href="#val-await"><code>await</code></a> them otherwise Miou will not consider these promises as resolved and will raise <code>Still_has_children</code>.</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  Miou.await_one
    [ Miou.call_cc (Fun.const 1)
    ; Miou.call_cc (Fun.const 2) ] ;;
Exception: Miou.Still_has_children</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> reschedules tasks and give an opportunity to carry out the tasks that have been on hold the longest. For intance:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Hello&quot; in
  print_endline &quot;World&quot;;
  Miou.await_exn p ;;
World
Hello
- : unit = ()
# Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Hello&quot; in
  Miou.yield ();
  print_endline &quot;World&quot;;
  Miou.await_exn p
Hello
World
- : unit = ()</code></pre></div></div><h3 id="cancellation."><a href="#cancellation." class="anchor"></a>Cancellation.</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cancelled"><a href="#exception-Cancelled" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cancelled</span></span></code></div><div class="spec-doc"><p>Used when a task is cancelled by <a href="#val-cancel"><code>cancel</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel prm</code> <i>asynchronously</i> cancels the given promise <code>prm</code>. Miou allows the forgetting of a cancelled promise and the forgetting of its children. For instance, this code is valid (despite the second one):</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  ignore (Miou.cancel (Miou.call (Fun.const ()))) ;;
- : unit = ()
# Miou.run @@ fun () -&gt;
  ignore (Miou.call (Fun.const ())) ;;
Exception: Miou.Still_has_children</code></pre><p>Cancellation terminates all the children. After the cancellation, the promise and its children all stopped. Resolved children are also cancelled (their results are erased). Cancelling a <i>resolved</i> promise that has already been <a href="#val-await"><code>await</code></a>ed does nothing:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc (Fun.const ()) in
  Miou.await_exn p;
  Miou.cancel p;
  Miou.await_exn p ;;
- : unit = ()</code></pre><p>However, cancellation does occur if a resolved promise was not awaited:</p><pre class="language-ocaml"><code># Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt; print_endline &quot;Resolved!&quot; in
  Miou.yield ();
  Miou.cancel p;
  Miou.await_exn p ;;
Resolved!
Exception: Miou.Cancelled.</code></pre><p>We can only <a href="#val-cancel"><code>cancel</code></a> for a promise that the task has created.</p><p><b>NOTE</b>: Cancellation <i>asynchronicity</i> means that other concurrent tasks can run while the cancellation is in progress. In fact, in the case of an cancellation of a parallel task (see <a href="#val-call"><code>call</code></a>), the cancellation may take a certain amount of time (the time it takes for the domains to synchronise) which should not affect the opportunity for other concurrent tasks to run.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span>?quanta:int <span class="arrow">&#45;&gt;</span></span>
  <span>?events:<span>(<span><a href="Domain/Uid/index.html#type-t">Domain.Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-events">events</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?g:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span>?domains:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div></div></body></html>