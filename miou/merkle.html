<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>merkle (miou.merkle)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">miou</a> &#x00BB; merkle</nav><header class="odoc-preamble"><h2 id="merkle-tree-and-parallelism."><a href="#merkle-tree-and-parallelism." class="anchor"></a>Merkle tree and parallelism.</h2><p>Miou allows you to perform tasks in parallel. This short tutorial will introduce 2 concepts offered by Miou:</p><ul><li>how to launch and obtain the results of parallel tasks</li><li>how to optimise Miou according to the type of application.</li></ul><p>The first problem relates more generally to parallel programming, while the second relates more specifically to Miou and its round-robin scheduler.</p><p>We would also like to make it clear that &quot;not everything is parallel&quot;. In the case of parallelism, ensuring that 2 tasks can agree on a specific memory state requires synchronisation mechanisms which can be costly.</p><p>The key question is not whether or not you can parallelise, but at what level you should parallelise and whether it's worth it.</p></header><nav class="odoc-toc"><ul><li><a href="#definitions-of-terms.">Definitions of terms.</a><ul><li><a href="#the-pool-of-domains.">The pool of domains.</a></li><li><a href="#fork-&amp;-join.">Fork &amp; Join.</a></li><li><a href="#the-dom0.">The <code>dom0</code>.</a></li></ul></li><li><a href="#a-merkle-tree.">A Merkle-tree.</a><ul><li><a href="#let's-run!">Let's run!</a></li></ul></li><li><a href="#parallelisation.">Parallelisation.</a><ul><li><a href="#first-iteration.">First iteration.</a></li><li><a href="#second-iteration.">Second iteration.</a></li><li><a href="#third-iteration.">Third iteration.</a></li></ul></li><li><a href="#miou-and-large-computations.">Miou and large computations.</a><ul><li><a href="#pure-and-impure-tasks.">Pure and impure tasks.</a></li><li><a href="#involvement-in-performance.">Involvement in performance.</a></li><li><a href="#quanta.">Quanta.</a></li><li><a href="#tuning-&amp;-results.">Tuning &amp; results.</a></li></ul></li><li><a href="#conclusion.">Conclusion.</a></li></ul></nav><div class="odoc-content"><h3 id="definitions-of-terms."><a href="#definitions-of-terms." class="anchor"></a>Definitions of terms.</h3><h4 id="the-pool-of-domains."><a href="#the-pool-of-domains." class="anchor"></a>The pool of domains.</h4><p>Miou has a very basic design as far as parallelisation is concerned: it will allocate several domains (depending on your number of cores) and put them on standby for tasks. So, a call to <a href="Miou/index.html#val-call"><code>Miou.call</code></a> corresponds to sending a task to these domains. Finally, one of these domains will take charge of the task and run it in parallel with <code>dom0</code>, which runs your main code.</p><p>This is called a domain pool. It's a fairly basic design that has the advantage of taking care of domain allocation and management (as well as synchronisation) while allowing the user to run a task in parallel.</p><h4 id="fork-&amp;-join."><a href="#fork-&amp;-join." class="anchor"></a>Fork &amp; Join.</h4><p>A recurring pattern in parallel programming the <i>fork and join</i>. It consists of &quot;divide and conquer&quot;. It is often possible to divide a long task into several smaller tasks and then implement a way of <i>merging</i> the results of these smaller tasks to obtain the expected final result.</p><p>This is perhaps the simplest pattern to use and one that can be applied to a whole host of basic problems. Miou drives the user to use such a pattern via the <a href="Miou/index.html#val-parallel"><code>Miou.parallel</code></a> function.</p><h4 id="the-dom0."><a href="#the-dom0." class="anchor"></a>The <code>dom0</code>.</h4><p>Miou allocates and makes available domains which expect tasks to run in parallel with <code>dom0</code>. <code>dom0</code> is the main domain on which your program runs - it is allocated by the system.</p><p><code>dom0</code> is different from the other domains in that it is the domain that considers the termination of your program. The other domains have neither the possibility nor the ability to stop your program. They do, however, have the prerogative to stop if <code>dom0</code> so wishes.</p><p>In this sense, <code>dom0</code> cannot receive tasks from other domains. A parallel task (launched by <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> or <a href="Miou/index.html#val-parallel"><code>Miou.parallel</code></a>) will never run on <code>dom0</code>. However, <code>dom0</code> can launch concurrent tasks (via <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a>).</p><h3 id="a-merkle-tree."><a href="#a-merkle-tree." class="anchor"></a>A Merkle-tree.</h3><p>Our objective is quite simple:</p><ul><li>obtain the hash of a file</li><li>obtain the hash of a folder which corresponds to the composition of the hashes of the sub-folders and files in that folder</li></ul><p>Let's start by obtaining the hash of a file:</p><pre class="language-ocaml"><code>module Hash = Digestif.SHA1

let hash_of_blob filename =
  let ic = open_in filename in
  let ln = in_channel_length ic in
  let rec go buf ctx =
    match input ic buf 0 (Bytes.length buf) with
    | 0 | (exception End_of_file) -&gt; Hash.get ctx
    | len -&gt;
        let ctx = Hash.feed_bytes ctx buf ~len in
        go buf ctx
  in
  let ctx = Hash.empty in
  let str = Fmt.str &quot;blob %d\000&quot; ln in
  let ctx = Hash.feed_string ctx str in
  let res = go (Bytes.create 0x1000) ctx in
  close_in ic; res</code></pre><p>This code basically calculates the hash of a file &quot;à la Git&quot; and returns the result. The calculation for a directory is a little more complex, and consists of using <code>Sys</code>.readdir, sorting the result and calculating the hash for all the items in the directory, then serialising (merging?) these hashes in a certain form and calculating the hash of this serialisation:</p><pre class="language-ocaml"><code>let ( / ) = Filename.concat

let rec hash_of_tree filename =
  let entries = Sys.readdir filename in
  let entries =
    List.map
      (fun v -&gt;
        let filename = filename / v in
        if Sys.is_directory filename then (`Dir, filename)
        else (`Normal, filename))
      (List.sort String.compare (Array.to_list entries))
      (* sort and recognize if it's a file or a directory. *)
  in
  hash_of_entries entries

and hash_of_entries entries =
  let entries =
    (* compute the hash of all items *)
    List.map
      (function
        | `Dir, filename -&gt;
            let name = Filename.basename filename in
            let hash = hash_of_tree filename in
            Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
        | `Normal, filename -&gt;
            let name = Filename.basename filename in
            let hash = hash_of_blob filename in
            Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))
      entries
  in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  (* serialisation *)
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><h4 id="let's-run!"><a href="#let's-run!" class="anchor"></a>Let's run!</h4><p>Finally, we just need a final function to handle the user's argument, such as:</p><pre class="language-ocaml"><code>let () =
  match Sys.argv with
  | [| _; filename |] when Sys.file_exists filename -&gt;
      if Sys.is_directory filename then
        let hash = hash_of_tree filename in
        Format.printf &quot;%a\n%!&quot; Hash.pp hash
      else
        let hash = hash_of_blob filename in
        Format.printf &quot;%a\n%!&quot; Hash.pp hash
  | [| _; filename |] -&gt;
      Format.eprintf &quot;%s: %s not found\n%!&quot; Sys.argv.(0) filename
  | _ -&gt; Format.eprintf &quot;%s &lt;filename&gt;\n%!&quot; Sys.argv.(0)</code></pre><p>We can compile the program with:</p><pre class="language-ocaml"><code>$ ocamlfind opt -linkpkg -package fmt,digestif,digestif.c main.ml
$ ./a.out $PWD
aa146b5524a5c7ed221efda5382beeabcbc58d54</code></pre><h3 id="parallelisation."><a href="#parallelisation." class="anchor"></a>Parallelisation.</h3><h4 id="first-iteration."><a href="#first-iteration." class="anchor"></a>First iteration.</h4><p>If you followed our explanation of patterns for parallel programming, you can already see where we might use <a href="Miou/index.html#val-call"><code>Miou.call</code></a> rather than sequentially executing the code. We're talking, of course, about the <code>List.map</code> in our <code>hash_of_entries</code> function. We could return promises (<code>fork</code>) rather than the result as such for each item. Finally, we could use <a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a> (<code>join</code>) as our synchronisation point. So let's make the change accordingly:</p><pre class="language-ocaml"><code>and hash_of_entries entries =
  let entries =
    List.rev_map
      (function
        | `Dir, filename -&gt;
            Miou.call @@ fun () -&gt; (* Add a [call] here! *)
            let name = Filename.basename filename in
            let hash = hash_of_tree filename in
            Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
        | `Normal, filename -&gt;
            Miou.call @@ fun () -&gt; (* Add a [call] here! *)
            let name = Filename.basename filename in
            let hash = hash_of_blob filename in
            Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))
      entries
  in
  let entries =
    List.rev_map
      (function Ok str -&gt; str | Error exn -&gt; raise exn)
      (Miou.await_all entries)
  in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><p>Note the double use of <code>List</code>.rev_map instead of <code>List</code>.map, which provides a <i>tail-rec</i> function.</p><h4 id="second-iteration."><a href="#second-iteration." class="anchor"></a>Second iteration.</h4><p>We have just applied our &quot;fork and join&quot; pattern where we divide the calculation of the hashes of our entries using <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> and we finish by: 1) waiting for the results of all these tasks (<a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a>) 2) merge the results to obtain a final hash</p><p>However, Miou is quite precise when it comes to assigning tasks in parallel to domains - it does so randomly! So it <b>may</b> happen that one of the domains has more tasks than another.</p><p>If we want to have a fair distribution of tasks across domains, we should use <a href="Miou/index.html#val-parallel"><code>Miou.parallel</code></a>:</p><pre class="language-ocaml"><code>and perform = function
  | `Dir, filename -&gt;
      let name = Filename.basename filename in
      let hash = hash_of_tree filename in
      Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
  | `Normal, filename -&gt;
      let name = Filename.basename filename in
      let hash = hash_of_blob filename in
      Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))

and hash_of_entries entries =
  let entries = Miou.parallel perform entries in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><p>Note that parallel starts and waits for tasks. Thus, the use of await_all is no longer necessary.</p><h4 id="third-iteration."><a href="#third-iteration." class="anchor"></a>Third iteration.</h4><p>There is one final problem with our code. If you've read our definitions carefully, you'll see that <code>dom0</code> does nothing but wait. This isn't always a problem because <code>dom0</code> could be busy doing something other than waiting, but in this specific application, all we're doing is trying to calculate the hashes.</p><p>So it can be interesting to involve <code>dom0</code> in the work. It is also said that, even if <code>dom0</code> cannot be assigned by the other domains to do a task in parallel, it can still do concurrently.</p><p>As far as our application is concerned, we are essentially doing 2 things, one of which may take some time:</p><ol><li>we 'traverse' the structure of our folders (by going into sub-folders and sub-sub-folders)</li><li>we calculate the file hash</li></ol><p>The task that takes the longest is the one we would parallelise (to share the time). The other task could be assigned to our <code>dom0</code>! In this way, the traversal could be taken by <code>dom0</code> and the rest in parallel:</p><pre class="language-ocaml"><code>and perform = function
  | `Dir, filename -&gt;
      Miou.call_cc @@ fun () -&gt;
      let name = Filename.basename filename in
      let hash = hash_of_tree filename in
      Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
  | `Normal, filename -&gt;
      Miou.call @@ fun () -&gt;
      let name = Filename.basename filename in
      let hash = hash_of_blob filename in
      Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))

and hash_of_entries entries =
  let entries = List.rev_map perform entries in
  let entries =
    List.rev_map
      (function Ok str -&gt; str | Error exn -&gt; raise exn)
      (Miou.await_all entries)
  in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><p>As you can see, we've just returned to the previous code with the subtlety of using <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> as soon as we need to traverse a directory.</p><p>It was also mentioned that the assignment of a task to a domain is random and that one domain may have more tasks than another. However, for a large number of tasks, we can consider that the distribution is <i>normal</i> - and that, roughly speaking, the tasks are assigned equitably.</p><h3 id="miou-and-large-computations."><a href="#miou-and-large-computations." class="anchor"></a>Miou and large computations.</h3><h4 id="pure-and-impure-tasks."><a href="#pure-and-impure-tasks." class="anchor"></a>Pure and impure tasks.</h4><p>The code we have just developed involves fairly limited system interaction (reading a folder or file) which does not, in this case, involve the use of <a href="Miou_unix/index.html"><code>Miou_unix</code></a>.</p><p>In this regard, the tasks in our application can be considered pure in the sense that they do not emit <i>a suspension effect</i> that is necessary when waiting for a system event. With a little hindsight, this means that we can roughly calculate the time it will take our tasks to execute.</p><p>It can then be interesting to prioritise tasks in relation to what they depend on. For example, we could have 2 <a href="Miou/index.html#val-await"><code>Miou.await</code></a>s, one for a task calculating the hash of a 1KB file, another for a task calculating the hash of a 1GB file. In this particular case, it would be more interesting to try the first <a href="Miou/index.html#val-await"><code>Miou.await</code></a> rather than the second (which would take longer).</p><p>This is task prioritisation and can be very useful for 'large computations'. However, Miou is more concerned with the development of system and network applications for which availability is more important (even if it means wasting time waiting for our second task rather than the first).</p><h4 id="involvement-in-performance."><a href="#involvement-in-performance." class="anchor"></a>Involvement in performance.</h4><p>The availability of tasks means that Miou can often attempt an <a href="Miou/index.html#val-await"><code>Miou.await</code></a> on a promise which associated task has not yet finished. We then waste some of our time observing, only to do nothing - and then move on to the next task.</p><p>This problem can be solved in 2 ways:</p><ol><li>don't use Miou and prefer a scheduler that implements task prioritisation (which may have other implications/flaws)</li><li>modify Miou's behaviour</li></ol><h4 id="quanta."><a href="#quanta." class="anchor"></a>Quanta.</h4><p>In truth, in our example, the real bottleneck slowing down our code is the number of <i>quantas</i>. In the case of our <code>dom0</code>, this limitation will consist of our domain launching a task (1 quanta) and then spending 1 quanta waiting for another task (which is certainly not finished) to finally reschedule the launch of a new task (1 quanta).</p><p>In other words, the launch of all our tasks is intermittently disrupted by unnecessary awaits... However, we definitely wanted to launch lots of tasks and then wait for all of them (<a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a>). But Miou makes sure that all the tasks (whether they are waiting and/or launching other tasks) consume the same number of quantas.</p><p>One way would be to allow a task, particularly the one we run on <code>dom0</code>, to consume enough quantas (and launch all our sub-tasks) without it having the intermittency of an <a href="Miou/index.html#val-await"><code>Miou.await</code></a> for the sake of fairness.</p><h4 id="tuning-&amp;-results."><a href="#tuning-&amp;-results." class="anchor"></a>Tuning &amp; results.</h4><p>We're going to compare the results and to do this, we're simply going to try and calculate the hash of our <code>&quot;.opam/5.0.0&quot;</code>:</p><pre class="language-ocaml"><code>dinosaure@turbine:~$ hyperfine --warmup=1 \
  'MIOU_QUANTA=1000000 ./miou_p.out ~/.opam/5.0.0' \
  './miou_s.out ~/.opam/5.0.0'
Benchmark 1: MIOU_QUANTA=1000000 ./miou_p.out ~/.opam/5.0.0
  Time (mean ± σ):     894.8 ms ±  25.3 ms    [User: 5394.3 ms, System: 1176.7 ms]
  Range (min … max):   852.1 ms … 939.8 ms    10 runs
 
Benchmark 2: ./miou_s.out ~/.opam/5.0.0
  Time (mean ± σ):      2.720 s ±  0.013 s    [User: 2.382 s, System: 0.334 s]
  Range (min … max):    2.702 s …  2.742 s    10 runs
 
Summary
  MIOU_QUANTA=1000000 ./miou_p.out ~/.opam/5.0.0 ran
    3.04 ± 0.09 times faster than ./miou_s.out ~/.opam/5.0.0</code></pre><p>The first version <code>&quot;miou_p&quot;</code> is the on that uses <a href="Miou/index.html#val-call"><code>Miou.call</code></a>. The second <code>&quot;miou_s&quot;</code> corresponds to our first code (without parallelisation). The parallelised version is at least 3 times faster!</p><p>Note the use of <code>MIOU_QUANTA</code>, which allows you to specify the number of quanta that a task can consume. In this case, to avoid wasting time (checking &quot;awaits&quot; unnecessarily), we consider that a task can consume up to 1000000 quantas (and therefore produce 1000000 effects, which is equivalent to saying: to launch 1000000 tasks at once without interruption).</p><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>This tutorial shows the subtleties that Miou can have with regard to parallel tasks. The second part also shows that Miou is not a scheduler that looks for the <b>optimal</b> order in which to execute tasks (considering, of factor, the intermittency of system events). Miou is more interested in the availability of tasks to be synchronised with system events than in prioritising tasks.</p><p>In this case, the example is not a system application: its interactions are not notified (quite rightly) to Miou - reading a file or folder is rarely blocking. Nonetheless, knowing the facts, it is still possible to obtain a high-performance application. The <a href="Miou/index.html#val-run"><code>Miou.run</code></a> function can be set so that tasks can consume more than one quanta.</p><p>This small example shows that the task execution management policy has an impact on the way an application is written. There is no one way of writing a scheduler and it is perhaps fairer to inform the user of the implications that our implementation may have in the development of applications (as we do in this tutorial) than to oversell a product.</p></div></body></html>