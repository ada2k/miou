<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>merkle (miou.merkle)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">miou</a> &#x00BB; merkle</nav><header class="odoc-preamble"><h2 id="merkle-tree-and-parallelism."><a href="#merkle-tree-and-parallelism." class="anchor"></a>Merkle tree and parallelism.</h2><p>The purpose of this short tutorial is to introduce you to some of the subtleties you need to know about <code>miou</code> and parallelism in relation to &quot;basic&quot; algorithms. We're going to try and parallelize the calculation of a hash of a folder, its sub-folders and its files: a sort of Git-style Merkle-tree.</p><p>First of all, before you start coding, you need to be clear about one thing: not everything can be parallelized! Parallelization requires what we call <i>synchronisation mechanisms</i>. These mechanisms can be more or less cumbersome because they have to adapt to a multitude of situations of varying complexity when it comes to calculating and sharing information between processors. In this respect, there are tasks that would be far too complex to parallelize and whose final gain would surely be disappointing.</p><p>Parallelization essentially consists of finding a point in your code where launching the task in parallel and obtaining its result would not be so costly compared to what the task does. In other words, if the synchronisation time required remains marginal compared to what the task does, we can imagine that running the task in parallel could save us some time.</p><p>Parallelization is not synonymous with performance either. In fact, it can be useful to parallelize tasks in order to separate them conceptually as well. For example, parallelizing a task when a connection is received is not really intended to make the server faster - but rather to separate the logic of the server from that of managing a client.</p><p>Parallelization is therefore not an option: 1) systematic 2) not just for performance reasons</p></header><nav class="odoc-toc"><ul><li><a href="#the-pool-of-domains.">The pool of domains.</a></li><li><a href="#a-merkle-tree.">A Merkle-tree.</a><ul><li><a href="#let's-run!">Let's run!</a></li></ul></li><li><a href="#parallelisation.">Parallelisation.</a><ul><li><a href="#starvation-problem.">Starvation problem.</a></li></ul></li><li><a href="#parallelism-&amp;-concurrency.">Parallelism &amp; concurrency.</a></li><li><a href="#results.">Results.</a></li><li><a href="#conclusion.">Conclusion.</a></li></ul></nav><div class="odoc-content"><h3 id="the-pool-of-domains."><a href="#the-pool-of-domains." class="anchor"></a>The pool of domains.</h3><p>Miou has a very basic design as far as parallelization is concerned: it will allocate several domains (depending on your number of cores) and put them on standby for tasks. So, a call to Miou.call corresponds to sending a task to these domains. Finally, one of these domains will take charge of the task and run it in parallel with dom0, which runs your main code.</p><p>This is called a domain pool. It's a fairly basic design that has the advantage of taking care of domain allocation and management (as well as synchronization) while allowing the user to run a task in parallel.</p><p>This also highlights a fairly simple pattern in parallel programming: fork &amp; join.</p><pre class="language-ocaml"><code>let tasks = List.map (fun fn -&gt; Miou.call fn) tasks in (* fork *)
Miou.await_all tasks (* and join *)</code></pre><p>This pattern is still the simplest: launch tasks in parallel and wait for the results of all these tasks. Here, our synchronisation mechanism corresponds to <a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a>, and using such a pattern with Miou is quite free.</p><p>You can imagine several other patterns, but limiting yourself to this one is still good practice, as the others involve more complex synchronisation mechanisms.</p><h3 id="a-merkle-tree."><a href="#a-merkle-tree." class="anchor"></a>A Merkle-tree.</h3><p>Our objective is quite simple:</p><ul><li>obtain the hash of a file</li><li>obtain the hash of a folder which corresponds to the composition of the hashes of the sub-folders and files in that folder</li></ul><p>Let's start by obtaining the hash of a file:</p><pre class="language-ocaml"><code>module Hash = Digestif.SHA1

let hash_of_blob filename =
  let ic = open_in filename in
  let ln = in_channel_length ic in
  let rec go buf ctx =
    match input ic buf 0 (Bytes.length buf) with
    | 0 | (exception End_of_file) -&gt; Hash.get ctx
    | len -&gt;
        let ctx = Hash.feed_bytes ctx buf ~len in
        go buf ctx
  in
  let ctx = Hash.empty in
  let str = Fmt.str &quot;blob %d\000&quot; ln in
  let ctx = Hash.feed_string ctx str in
  let res = go (Bytes.create 0x1000) ctx in
  close_in ic; res</code></pre><p>This code basically calculates the hash of a file &quot;à la Git&quot; and returns the result. The calculation for a directory is a little more complex, and consists of using <code>Sys</code>.readdir, sorting the result and calculating the hash for all the items in the directory, then serialising these hashes in a certain form and calculating the hash of this serialisation:</p><pre class="language-ocaml"><code>let ( / ) = Filename.concat

let rec hash_of_tree filename =
  let entries = Sys.readdir filename in
  let entries =
    List.map
      (fun v -&gt;
        let filename = filename / v in
        if Sys.is_directory filename then (`Dir, filename)
        else (`Normal, filename))
      (List.sort String.compare (Array.to_list entries))
      (* sort and recognize if it's a file or a directory. *)
  in
  hash_of_entries entries

and hash_of_entries entries =
  let entries =
    (* compute the hash of all items *)
    List.map
      (function
        | `Dir, filename -&gt;
            let name = Filename.basename filename in
            let hash = hash_of_tree filename in
            Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
        | `Normal, filename -&gt;
            let name = Filename.basename filename in
            let hash = hash_of_blob filename in
            Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))
      entries
  in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  (* serialisation *)
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><h4 id="let's-run!"><a href="#let's-run!" class="anchor"></a>Let's run!</h4><p>Finally, we just need a final function to handle the user's argument, such as:</p><pre class="language-ocaml"><code>let () =
  match Sys.argv with
  | [| _; filename |] when Sys.file_exists filename -&gt;
      if Sys.is_directory filename then
        let hash = hash_of_tree filename in
        Format.printf &quot;%a\n%!&quot; Hash.pp hash
      else
        let hash = hash_of_blob filename in
        Format.printf &quot;%a\n%!&quot; Hash.pp hash
  | [| _; filename |] -&gt;
      Format.eprintf &quot;%s: %s not found\n%!&quot; Sys.argv.(0) filename
  | _ -&gt; Format.eprintf &quot;%s &lt;filename&gt;\n%!&quot; Sys.argv.(0)</code></pre><p>We can compile the program with:</p><pre class="language-ocaml"><code>$ ocamlfind opt -linkpkg -package fmt,digestif,digestif.c main.ml
$ ./a.out $PWD
aa146b5524a5c7ed221efda5382beeabcbc58d54</code></pre><h3 id="parallelisation."><a href="#parallelisation." class="anchor"></a>Parallelisation.</h3><p>If you followed our explanation of patterns for parallel programming, you can already see where we might use <a href="Miou/index.html#val-call"><code>Miou.call</code></a> rather than sequentially executing the code. We're talking, of course, about the <code>List.map</code> in our <code>hash_of_entries</code> function. We could return promises (<code>fork</code>) rather than the result as such for each item. Finally, we could use <a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a> (<code>join</code>) as our synchronisation point. So let's make the change accordingly:</p><pre class="language-ocaml"><code>and hash_of_entries entries =
  let entries =
    List.rev_map
      (function
        | `Dir, filename -&gt;
            Miou.call @@ fun () -&gt; (* Add a [call] here! *)
            let name = Filename.basename filename in
            let hash = hash_of_tree filename in
            Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
        | `Normal, filename -&gt;
            Miou.call @@ fun () -&gt; (* Add a [call] here! *)
            let name = Filename.basename filename in
            let hash = hash_of_blob filename in
            Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))
      entries
  in
  let entries =
    if [] = entries then []
    else
      List.rev_map
        (function Ok str -&gt; str | Error exn -&gt; raise exn)
        (Miou.await_all entries)
  in
  let ctx = Hash.empty in
  let len = List.fold_left (fun acc str -&gt; acc + String.length str) 0 entries in
  let str = Fmt.str &quot;tree %d\000&quot; len in
  let ctx = Hash.feed_string ctx str in
  let ctx =
    List.fold_left (fun ctx str -&gt; Hash.feed_string ctx str) ctx entries
  in
  Hash.get ctx</code></pre><p>Note the double use of <code>List</code>.rev_map instead of <code>List</code>.map, wich provides a <i>tail-rec</i> function. Finally, <a href="Miou/index.html#val-await_all"><code>Miou.await_all</code></a> necessarily expects a non-empty list - otherwise it raises an exception. However, this code won't work, it will even wait indefinitely.</p><h4 id="starvation-problem."><a href="#starvation-problem." class="anchor"></a>Starvation problem.</h4><p>The reason this code doesn't work is the recursion and the limited number of domains waiting. Miou allocates a certain number of domains (your number of cores - 1). Let's imagine that it only allocates 3 domains (for 4 cores). If we have a folder structure such that <code>&quot;a/b/c/d&quot;</code> exists, domain 1 will attempt to calculte <code>&quot;a&quot;</code>, domain 2 will calculate <code>&quot;b&quot;</code> and domain 3 will calculate <code>&quot;c&quot;</code>. However, to obtain the result of <code>&quot;c&quot;</code>, we need the result of <code>&quot;d&quot;</code> and we have no more domains available! We've just run into the starvation problem.</p><p>Miou only has limited number of domains (which can be increased by <a href="Miou/index.html#val-run"><code>Miou.run</code></a> via the <code>domains</code> argument - but we don't recommend that) and we need to take this into account and manage this resource sparingly.</p><p>There are methods that avoid the starvation problem, but they require <i>task prioritisation</i> - however, this method would be contrary to one of our precepts (linked to security): randomly choose which task we want to run.</p><h3 id="parallelism-&amp;-concurrency."><a href="#parallelism-&amp;-concurrency." class="anchor"></a>Parallelism &amp; concurrency.</h3><p>So how do we get around this? Well, the real question is: what's the point in parallelizing? If we deduce the execution of our code, it's easy to see that <code>hash_of_blob</code> is surely the longest function, as it may have to calculate the hash for large files. <code>hash_of_entries</code> remains fairly basic; we could have 1 million entries, but it would still be smalled than a 1 GB file. In other words, we should only parallelize the calculation of a file and only have one <a href="Miou/index.html#val-call"><code>Miou.call</code></a>, when the entry is a file (<code>`Normal</code>).</p><p>Another problem persists, this time with the OCaml type system. If we delete the <a href="Miou/index.html#val-call"><code>Miou.call</code></a> when we have a directory, we have a heterogeneous list (which contains both the result for directories and promises for files). We need to unify all this: this is where <a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> comes in!</p><pre class="language-ocaml"><code>let entries =
  List.rev_map
    (function
      | `Dir, filename -&gt;
          Miou.call_cc @@ fun () -&gt;
          let name = Filename.basename filename in
          let hash = hash_of_tree filename in
          Fmt.str &quot;40000 %s\000%s&quot; name (Hash.to_raw_string hash)
      | `Normal, filename -&gt;
          Miou.call @@ fun () -&gt;
          let name = Filename.basename filename in
          let hash = hash_of_blob filename in
          Fmt.str &quot;100644 %s\000%s&quot; name (Hash.to_raw_string hash))
    entries
in</code></pre><p><a href="Miou/index.html#val-call_cc"><code>Miou.call_cc</code></a> also returns a promise like <a href="Miou/index.html#val-call"><code>Miou.call</code></a>. However, instead of being executed on another domain in parallel, the task will be executed <i>later</i> on the <b>which created</b> the promise. For OCaml aficionados, this is a return to the idea of pre-OCaml 5.0 concurrent scheduling!</p><p>The idea is that hashes for directories will <b>only</b> be calculted on the main domain and only the calculation for files will be parallelized for the other domains - the latter will no longer depend on the result of a recursion.</p><p>So we've mixed parallelism and concurrency.</p><h3 id="results."><a href="#results." class="anchor"></a>Results.</h3><p>We're going to compare the results and to do this, we're simply going to try and calculate the hash of our <code>&quot;.opam&quot;</code>:</p><pre class="language-ocaml"><code>dinosaure@turbine:~$ hyperfine --warmup=1 './miou_p.out ~/.opam/5.0.0' './miou_s.out ~/.opam/5.0.0'
Benchmark 1: ./miou_p.out ~/.opam/5.0.0
  Time (mean ± σ):     760.1 ms ±  45.1 ms    [User: 6148.9 ms, System: 760.8 ms]
  Range (min … max):   661.5 ms … 840.8 ms    10 runs
 
Benchmark 2: ./miou_s.out ~/.opam/5.0.0
  Time (mean ± σ):      2.723 s ±  0.016 s    [User: 2.414 s, System: 0.305 s]
  Range (min … max):    2.694 s …  2.748 s    10 runs
 
Summary
  ./miou_p.out ~/.opam/5.0.0 ran
    3.58 ± 0.21 times faster than ./miou_s.out ~/.opam/5.0.0</code></pre><p>The first version <code>&quot;miou_p&quot;</code> is the on that uses <a href="Miou/index.html#val-call"><code>Miou.call</code></a>. The second <code>&quot;miou_s&quot;</code> corresponds to our first code. The parallelized version is at least 3 times faster!</p><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>As you can see, parallelising code is never a simple matter. The example here is basic, but it highlights the starvation problem. Using system resources is always difficult and choices can be made based on speed, security and ease of use. As far as we're concerned, Miou remains fairly basic in what it proposes and concentrates mainly on system and network programming where security issues may appear to be crucial - even if this is at the expense of apparent simplicity.</p><p>This tutorial explains the two ways of making a promise with Miou that <i>will</i> be executed. You can launch a <i>local</i> task to the domain where you are or launch a task on another domain. The two have different properties. Here's an example:</p><ul><li>for the first, the use of data structures such as <code>Hashtbl</code> can be considered</li><li>for the second, synchronisation mechanism are required (Condition, Mutex) but offer the lattitude to use all your computer's calculating resources</li></ul><p>Other properties exist, but we won't lis them all here. Welcome to the world of parallelism!</p></div></body></html>