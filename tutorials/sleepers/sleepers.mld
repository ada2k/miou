{1 Sleepers: how to inject syscalls into [miou]?}

This tutorial shows how to inject a new syscall to [miou] and extend the API of it
with {i blocking} operations. For the example, we're going to implement the
sleepers. [Unix.sleepf] is a blocking operation. The fundamental problem with
[miou] is that it performs operations in the background (scheduling). So using a
blocking operation with [miou] prevents it from managing other tasks
concurrently (manage tasks entered with {!val:Miou.call_cc}) or in parallel
(wait for parallel process tasks introduced by {!val:Miou.call}). 

As stated in the documentation, and this is a fundamental rule:
> you should never give [miou] blocking tasks (such as [Unix.sleepf])

That said, how do you manage blocking tasks? [miou] offers an API that allows
you to extend its API with such tasks. The idea is to inform [miou] of a promise
that is {b not} associated with a task (because the latter would be blocking)
and to notify it of the task that we would like to do as soon as we are {b sure}
that it is a non-blocking task.

This notification is possible because [miou] lets you inject such a function
which will notify it. This is the [events] function expected as a parameter to
the {!val:Miou.run} function.

{2 What we want to do?}

So let's get down to business. The aim of this tutorial is to enable you to
write this code:

{[
open Miou

let program () = Miou.run @@ fun () ->
  let a = Miou.call_cc (fun () -> sleep 1.) in
  let b = Miou.call_cc (fun () -> sleep 2.) in
  Miou.await_all_ign [ a; b ]

let () =
  let t0 = Unix.gettimeofday () in
  program ();
  let t1 = Unix.gettimeofday () in
  assert (t1 -. t0 < 3.)
]}

This code explains simple behaviour: our tasks [a] and [b] should run
concurrently. In other words, in the end, we should consume strictly less than 3
seconds (about 2 seconds) to complete this little program.

You can have fun replacing [sleep] with [Unix.sleepf] and you'll see that we're
back to a simple sequential execution where we need 3 seconds to finish the
program. And that's normal, [miou] doesn't know that [Unix.sleepf] is blocking,
so it will execute the two tasks one after the other without scheduling them
correctly.

So we've got our test, which will validate what we're expecting.

{2 Syscalls.}

The {!module:Miou} module is fairly straightforward about what can (and
cannot) be done about {i promises} not associated with a task. You can create
such a promise ({!val:Miou.make}), {b suspend} and wait for its result
{!val:Miou.suspend}) and obtain its unique identifier ({!val:Miou.uid}).
And that's it!

The first function allows us to create our [sleep] "syscall". The second will
allow us to specify the point at which we would like to obtain the result of our
blocking operation and the third function will allow us to {b keep} (and
{b store}) this {i promise} so that we can find it again later.

{[
open Miou

let sleepers = Hashtbl.create 0x100

let sleep until =
  let promise = Miou.make ~return:(Fun.const ()) in
  Hashtbl.add sleepers (Miou.uid promise) (promise, until);
  match Miou.suspend promise with
  | Ok () -> ()
  | Error exn -> raise exn
]}

As you can see, the implementation of a 'syscall' is relatively simple, but it
is always associated with the implementation or extension of another function:
the [events] function. The [return] value is the function that is called as
soon as the promise {b is} resolved. In our case, we would like to return
[() : unit] but we could very well return the value of a reference that the task
of resolving our promise will modify correctly.

[miou] is quite stupid, trying to carry out all the tasks we give it in the hope
that they will solve our promises. And it does this as long as it has at least
one unresolved promise. In our case, the promise we've just created will never
be resolved by any task. To clarify [miou]'s behaviour in this situation, you
can run this code:

{[
let dummy _ =
  { select= Fun.const []
  ; interrupt= ignore }

let () = Miou.(run ~events:dummy @@ fun () -> sleep 1.; ())
Exception: Miou.Still_has_children
]}

This code will finish with an exception [Still_has_children]:
+ a promise (our [sleep]) exists and is still unresolved
+ there is no task associated with our [sleep]
+ [miou] will simply try to finish your task but, remember our rules, all
  of our children must be resolved {b before} the end of our task

But as you can see, I've specified an [events] function here which always
returns an empty list. In truth, if [miou] has no more tasks to do and there are
still promises, it will try one last thing: execute our [events] function. This
can return a new task (always non-blocking) that could resolve a given promise.
And it's here that we'll be able to inject the tasks that will resolve our
sleepers.

Contrary to what we have just said, this [events] function (and only this one)
{b can block}! And, in reality, this is not a problem as all the tasks have been
executed. We can therefore be in a {i busy waiting} state for the next event to
unblock our execution flow.

In our case, it's a case of taking the {b smallest} sleeper, waiting and then
returning a task that resolves that same sleeper. We also need to update the
other sleepers because we're going to consume time.

{[
let select () =
  let min = Hashtbl.fold (fun uid (prm, until) -> function
    | Some (_uid', _prm', until') when until < until' ->
        Some (uid, prm, until)
    | Some _ as acc -> acc
    | None -> Some (uid, prm, until) sleepers None in
  match min with
  | None -> None
  | Some (uid, prm, until) ->
    Hashtbl.remove sleepers uid;
    Hashtbl.filter_map_inplace
      (fun _ (prm, until') -> Some (prm, Float.max 0. (until' -. until)))
      sleepers;
    Unix.sleepf until;
    Some [ Miou.syscall prm (Fun.const ()) ]

let events =
  { select; interrupt= ignore }
]}

{2 Usage.}

Now that we have our [events] function and our {i syscall} [sleep], we can use
them:

{[
let prgm () =
  Miou.run ~events @@ fun () ->
  let a = Miou.call_cc (fun () -> sleep 1.) in
  let b = Miou.call_cc (fun () -> sleep 2.) in
  ignore (Miou.await a);
  ignore (Miou.await b)

let () =
  let t0 = Unix.gettimeofday () in
  prgm ();
  let t1 = Unix.gettimeofday () in
  assert (t1 -. t0 < 3.)
]}

Note that our [events] function has been transferred to {!val:Miou.run}! Without
it, our code wouldn't work. And that's it! Our program did not fail to run,
which means that we used {b less} than 3 seconds (about 2).

{[
$ ocamlfind opt -linkpkg -package miou main.ml
$ ./a.out
$ echo $?
0
]}

And now we have proof that our 2 processes ran "at the same time". We say that
they ran cooperatively. Sleepers are a good example for understanding the
syscalls mechanism with [miou], but of course you can extend this yourself with
[read], [write] and [select] as functions notifying us of system events.

{2 The reason behind this API.}

The notion of "injection" was mentioned a few times, which consists of giving
the user the possibility of implementing the syscalls they want. The main reason
for this API is that it is not dependent on the [Unix] module. In fact, apart
from being particularly consistent, we believe that the I/O issue is not an
issue that fits into the {i scheduling} problem, but is intrinsic to scheduling.
In other words, we can make a library about {i scheduling} that does not require
and provide I/O solutions.

What's more, the I/O is actually quite subtle from one system to another. The
behaviour of [connect()], for example, bears witness to this between {b Linux}
and {b *BSD}. This means that we have to come up with an implementation that
behaves in the same way regardless of the system - as you can imagine, this is a
tedious and difficult job. Above all, it's work that may have nothing to do with
scheduling.

So the aim is to transfer all this complexity away from what [miou] does best:
scheduling. Of course, we're not leaving the user as it is, and we're offering
an extension to [miou] with the implemented I/O cleverly called [miouu] ([miou]
with [U]nix).

{2 Events & domains.}

As you can imagine, this little introduction is not complete if we take into
account {!val:Miou.call}. [miou] can launch tasks in parallel and these tasks
can perform I/O. On this point, we propose a fairly simple design: a {i syscall}
is always managed by the domain that launched it (it is somewhat equivalent to
{!val:Miou.call_cc}).

Above all, this means that I/O operations will always be cooperative. There may
be more complex tasks which can run in parallel and which may contain some I/O,
but the suspension ({!val:Miou.suspend}) of a syscall will always be local
to the current domain executing the suspension.

The suspension mechanism can therefore appear in a domain, but we can assure you
that only this domain will transmit the task resolving the suspended promise. If
the user, through some obscure game, tries to resolve a promise in a domain
other than the one with the suspension, [miou] will stop with [Invalid_syscall].
