<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interacting with the system - Miou, a simple scheduler for OCaml 5</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="synchronous_server.html"><strong aria-hidden="true">2.</strong> A synchronous server</a></li><li class="chapter-item expanded "><a href="scheduler.html"><strong aria-hidden="true">3.</strong> A simple scheduler</a></li><li class="chapter-item expanded "><a href="interacting_system.html" class="active"><strong aria-hidden="true">4.</strong> Interacting with the system</a></li><li class="chapter-item expanded "><a href="retrospective.html"><strong aria-hidden="true">5.</strong> Retrospective</a></li><li class="chapter-item expanded "><a href="echo.html"><strong aria-hidden="true">6.</strong> An echo server with Miou</a></li><li class="chapter-item expanded "><a href="sleepers.html"><strong aria-hidden="true">7.</strong> Interacting with the system with Miou</a></li><li class="chapter-item expanded "><a href="conditions_and_mutexes.html"><strong aria-hidden="true">8.</strong> Conditions & Mutexes</a></li><li class="chapter-item expanded "><a href="manifesto.html"><strong aria-hidden="true">9.</strong> Manifesto</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Miou, a simple scheduler for OCaml 5</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interacting-with-the-system"><a class="header" href="#interacting-with-the-system">Interacting with the system</a></h1>
<p>In the implementation of our <code>echo</code> server, beyond the question of
synchronicity, there were also considerations about interactions with the system
and the resources it provides, such as sockets.</p>
<p>We noticed that to manage these resources, we had functions described as
"blocking", meaning they waited for specific events (such as a new client
connection) before proceeding. Apart from wanting to delegate tasks in the
background, we also aimed to leverage these situations to perform other tasks.</p>
<p>We have this opportunity with <code>Await</code>, which observes the state of our promise
and then decides to continue if it contains the result of our task or to "yield"
(i.e., execute other tasks) if the associated task is not yet complete.</p>
<p>We could reproduce the same approach for these blocking functions: continue if
they have an event to notify us about, or "yield" if we know they will block.
The crucial question then is to predict in advance whether they will block.
Fortunately, the system can provide us with this information.</p>
<h2 id="file-descriptors"><a class="header" href="#file-descriptors">File-descriptors</a></h2>
<p>In our first chapter, we introduced the concept of file descriptors. These are
system resources used to manage I/O operations such as handling client
connections, transmitting bytes, and more. It's essential to monitor the state
of these resources and determine beforehand whether functions like <code>accept()</code>
(for managing a new client) will block or not.</p>
<p>Typically, we can consider that all our functions interacting with the system
block by default. However, we can periodically check our active file descriptors
to determine if we can safely resume functions that will perform these blocking
system calls.</p>
<p>Monitoring the state of our active file descriptors and determining if an event
(which would unblock our functions) occurs is done using the <code>select()</code>
function:</p>
<pre><code class="language-ocaml">val select :
    file_descr list -&gt; file_descr list -&gt; file_descr list -&gt;
      float -&gt; file_descr list * file_descr list * file_descr list
</code></pre>
<p>This function takes several arguments, but only 3 are of interest to us. The
first and second arguments pertain to monitoring file descriptors that are
awaiting "read" and "write" operations, respectively. Typically, when we want to
wait for a client connection, we are waiting for a "read" operation on our file
descriptor. If we intend to transmit bytes to the client, we are waiting to be
able to "write" to our file descriptor. The last argument that concerns us is
the timeout for this observation. A reasonably short time is sufficient; let's
say 10ms.</p>
<p>For example, let's consider our <code>accept()</code> function. We want to determine
whether we should execute <code>accept()</code> without blocking:</p>
<pre><code class="language-ocaml">let rec our_accept file_descr =
  print_endline "Monitor our file-descriptor.";
  match Unix.select [ file_descr ] [] [] 0.01 with
  | [], _, _ -&gt; our_accept file_descr
  | file_descr :: _, _, _ -&gt; Unix.accept file_descr

let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  let client, sockaddr = our_accept socket in
  Unix.close client;
  Unix.close socket
</code></pre>
<p>Let's test this code and see what happens.</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; sleep 1; netcat -q0 localhost 3000
Monitor our file-descriptor.
Monitor our file-descriptor.
Monitor our file-descriptor.
...
[1]  + 6210 done       ./a.out
</code></pre>
<p>Testing this code reveals the repeated "Monitoring our file-descriptor."
messages until the program ends (after receiving a connection using <code>netcat</code>
after 1 second). What's interesting here is that instead of blocking on
<code>accept()</code>, we execute it only if <code>select()</code> informs us that our file descriptor
is indeed ready (meaning it has received an incoming connection). If not, we
retry the observation by calling <code>select()</code> again.</p>
<p>In more concrete terms, we are no longer in a situation where we indefinitely
wait for an event to unblock us, but rather we wait for just 10ms to retry an
observation or execute our <code>accept()</code> if ready. We've found a way to determine
in advance whether our function will block or not.</p>
<h2 id="integration-into-our-scheduler"><a class="header" href="#integration-into-our-scheduler">Integration into our scheduler</a></h2>
<p>Now, the advantage of <code>select()</code> is that it can observe <strong>multiple</strong> file
descriptors (not just one as in our example). Our goal is to provide an
<code>our_accept</code> function that doesn't block. In case our file descriptor isn't
ready (which is the default case, as a reminder, all our system functions
block), we'll reuse our <code>Await</code> to suspend the execution before actually
performing our <code>accept()</code>. This suspension will give us the opportunity to
execute other tasks.</p>
<pre><code class="language-ocaml">let waiting_fds_for_reading = Hashtbl.create 0x100

let our_accept file_descr =
  let value = ref None in
  Hashtbl.add waiting_fds_for_reading file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_reading file_descr;
  Unix.accept file_descr
</code></pre>
<p>Finally, periodically, we'll observe all the file descriptors that are waiting.
<code>select()</code> will inform us about those that can be unblocked. We just need to
<em>fulfill</em> our promise so that our scheduler can resume our suspended function.</p>
<pre><code class="language-ocaml">let fullfill tbl fd =
  let value = Hashtbl.find tbl fd in
  value := Some ()

let our_select () =
  let rds = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_reading) in
  let rds, _, _ = Unix.select rds [] [] 0.01 in
  List.iter (fullfill waiting_fds_for_reading) rds
</code></pre>
<p>Ultimately, we just need to call <code>our_select()</code> periodically. We previously
mentioned that our scheduler tries to resolve our tasks step by step. We'll
interleave these steps with this observation. This way, we'll be almost
immediately aware of the occurrence of events (within 10ms and a snippet of a
task execution).</p>
<pre><code class="language-ocaml">let run fn =
  let result = ref None in
  let rec go = function
    | [] -&gt; Option.get !result
    | Task task :: rest -&gt;
        let todo = ref rest in
        let todo =
          match step todo task with
          | Resolved _ -&gt; !todo
          | (Initial _ | Suspended _) as task -&gt; !todo @ [ Task task ]
        in
        our_select (); go todo
  in
  let task = Initial (fun () -&gt; result := Some (fn ())) in
  go [ Task task ]
</code></pre>
<h2 id="lets-try"><a class="header" href="#lets-try">Let's try!</a></h2>
<p>Let's revisit our example with <code>accept()</code>:</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  let client, sockaddr = our_accept socket in
  Unix.close client;
  Unix.close socket

let () = run server
</code></pre>
<p>If we execute our server with our scheduler:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; netcat -q0 localhost 3000
[1] 38255
[1]  + 38255 done       ./a.out
</code></pre>
<p>We notice that our program does not indefinitely block. It only blocks
periodically for 10ms<sup class="footnote-reference"><a href="#busy-loop">1</a></sup> and observes the active file descriptors (in
our <code>waiting_fds_for_reading</code> table). Finally, as soon as <code>netcat</code> connects, we
can resume our <code>our_accept</code> function and continue executing our program. With
the ability to put tasks in the background, we can now attempt to reimplement
our server asynchronously. However, we need to provide, just like <code>our_accept</code>,
<code>our_read</code> and <code>our_write</code>. The first one will reuse our
<code>waiting_fds_for_reading</code> table, while the second one will use a new table to
determine if our file descriptors are ready to transmit bytes.</p>
<pre><code class="language-ocaml">let our_read file_descr buf off len =
  let value = ref None in
  Hashtbl.add waiting_fds_for_reading file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_reading file_descr;
  Unix.read file_descr buf off len

let waiting_fds_for_writing = Hashtbl.create 0x100

let our_write file_descr buf off len =
  let value = ref None in
  Hashtbl.add waiting_fds_for_writing file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_writing file_descr;
  Unix.write file_descr buf off len

let our_select () =
  let rds = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_reading) in
  let wrs = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_writing) in
  let rds, wrs, _ = Unix.select rds wrs [] 0.01 in
  List.iter (fullfill waiting_fds_for_reading) rds;
  List.iter (fullfill waiting_fds_for_writing) wrs
</code></pre>
<p>Now, we can both await new connections and manage in background our clients:</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = our_read client buf 0 (Bytes.length buf) in
  if len = 0 then Unix.close client
  else let _ = our_write client buf 0 len in echo client

let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  while true do
    let client, address_of_client = our_accept socket in
    ignore (spawn @@ fun () -&gt; echo client)
  done;
  Unix.close socket;
  print_endline "Server terminated"

let () = run server
</code></pre>
<p>To test this code, simply launch your server and run 2 <code>netcat</code> instances
simultaneously (in 2 different terminals). You'll notice that our server no
longer blocks and can handle these 2 clients "simultaneously". We have finally
succeeded in creating an asynchronous server with effects in OCaml.</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; \
  echo "Salut"|netcat -q0 localhost 3000; \
  echo "Hello"|netcat -q0 localhost 3000
[1] 40381
Salut
Hello
$ kill -9 40381
[1]  + 40381 killed     ./a.out
</code></pre>
<p>At this point, all the basic concepts of a scheduler and asynchronous
programming have been explained. It's time to take a look back at what we've
learned and, most importantly, start comparing it with Miou in the next chapter.</p>
<div class="footnote-definition" id="busy-loop"><sup class="footnote-definition-label">1</sup>
<p>The purpose of the 10ms interval is to prevent our program from
falling into what is known as a <a href="https://en.wikipedia.org/wiki/Busy_waiting">"busy-loop"</a>. Indeed, these 10ms
intervals notify our system that our program will do nothing during this time
period unless an event occurs. Our system is then able to put our program to the
<em>sleep</em> mode and also take the opportunity to do something else. What is certain
is that this <em>sleep</em> mode allows our program not to monopolize the processor. In
the case of a "busy-loop," our program would be the only one able to run, and
you would likely hear your processor fan whirring loudly.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="scheduler.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="retrospective.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="scheduler.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="retrospective.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
