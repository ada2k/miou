<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Miou, a simple scheduler for OCaml 5</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="synchronous_server.html"><strong aria-hidden="true">2.</strong> A synchronous server</a></li><li class="chapter-item expanded "><a href="scheduler.html"><strong aria-hidden="true">3.</strong> A simple scheduler</a></li><li class="chapter-item expanded "><a href="interacting_system.html"><strong aria-hidden="true">4.</strong> Interacting with the system</a></li><li class="chapter-item expanded "><a href="retrospective.html"><strong aria-hidden="true">5.</strong> Retrospective</a></li><li class="chapter-item expanded "><a href="echo.html"><strong aria-hidden="true">6.</strong> An echo server with Miou</a></li><li class="chapter-item expanded "><a href="sleepers.html"><strong aria-hidden="true">7.</strong> Interacting with the system with Miou</a></li><li class="chapter-item expanded "><a href="conditions_and_mutexes.html"><strong aria-hidden="true">8.</strong> Conditions & Mutexes</a></li><li class="chapter-item expanded "><a href="manifesto.html"><strong aria-hidden="true">9.</strong> Manifesto</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Miou, a simple scheduler for OCaml 5</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="miou-a-simple-scheduler-for-ocaml-5"><a class="header" href="#miou-a-simple-scheduler-for-ocaml-5">Miou, a simple scheduler for OCaml 5</a></h1>
<p>Miou is a small library that facilitates asynchronous and parallel programming
in OCaml. It is a project of the <a href="https://robur.coop">Robur</a> cooperative, aimed at developing
system and network applications. This library only requires OCaml 5 and can be
obtained via <a href="https://opam.ocaml.org">opam</a>.</p>
<pre><code class="language-shell">$ opam install miou
</code></pre>
<p>Miou offers three key features:</p>
<ul>
<li>a multi-domain runtime for executing asynchronous code.</li>
<li>flexibility in defining interactions between the system and Miou.</li>
<li>essential components for asynchronous and/or parallel programming.</li>
</ul>
<h2 id="mious-role-in-your-project"><a class="header" href="#mious-role-in-your-project">Miou's role in your project</a></h2>
<p>When developing an application that heavily interacts with the system to offer
services like an HTTP server, embracing asynchronous programming is recommended.
However, OCaml lacks built-in support for asynchronous programming,
necessitating the use of a library such as Miou, which provides the required
runtime.</p>
<p>Such a runtime emerges as a pivotal element of your application, orchestrating
and executing tasks to ensure continued service availability despite varying
workloads. Miou caters to diverse systems, ranging from unikernels to large
servers with numerous cores or even small embedded devices.</p>
<p>While pivotal, this runtime represents the final frontier between your
application's intended functionality and its current execution by interacting
with the system. Hence, we advise users to defer selecting the scheduler, such
as Miou, until the application's design phase is complete.</p>
<h3 id="a-multi-domain-runtime"><a class="header" href="#a-multi-domain-runtime">A multi-domain runtime</a></h3>
<p>Since OCaml 5, it has been possible to execute tasks in parallel. Miou provides
this capability by solving the inter-domain synchronization problems involved.
Miou allocates multiple domains that are available to the user to manage in
parallel, for example, clients.</p>
<p>We recommend referring to the OCaml manual to learn more about domains. Indeed,
Miou manages domains itself because they can be a costly resource. As such, Miou
handles their allocation, transfers your tasks to them, manages synchronization
when you want to obtain the results of your tasks, and ultimately deallocates
these domains properly.</p>
<h3 id="agnostic-to-the-system"><a class="header" href="#agnostic-to-the-system">Agnostic to the system</a></h3>
<p>Miou only requires OCaml to operate. This choice stems from our ambition to
integrate Miou as a scheduler for our unikernels, which are highly specialized
systems. However, more generally and based on experience, we understand that
interactions with the system are inherently complex and cannot be standardized
through a common interface.</p>
<p>Therefore, we believe that the best person to determine how to interact with
the system is you! Miou thus provides this capability so that you can leverage
the full potential of your system.</p>
<p>However, Miou offers a small extension allowing interaction with your system
through the <code>miou.unix</code> library. While rudimentary, it is adequate for most
system and network applications.</p>
<h3 id="essential-components-for-asynchronousparallel-programming"><a class="header" href="#essential-components-for-asynchronousparallel-programming">Essential components for asynchronous/parallel programming</a></h3>
<p>Finally, Miou provides essential elements for parallel and/or asynchronous
programming. These components help address synchronization challenges inherent
in parallel and/or asynchronous programming.</p>
<p>It is worth noting that these elements may seem somewhat rudimentary. However,
we would like to caution the user that the topic of synchronization is a vast
realm of solutions and research, and we do not claim to have omniscience over
it. Therefore, we prefer to leave this space open for the user.</p>
<h2 id="when-not-to-use-miou"><a class="header" href="#when-not-to-use-miou">When not to use Miou</a></h2>
<p>Although Miou is useful for many projects that need to do a lot of things
simultaneously, there are also some use-cases where Miou is not a good fit:
speeding up CPU-bound computations by running them in parallel on several
domains. Miou is designed for IO-bound applications where each individual task
spends most of its time waiting for IO. If the only thing your application
does is run computations in parallel, you should use <a href="https://github.com/c-cube/moonpool">moonpool</a>. That
said, it is still possible to "mix &amp; match" if you need to do both.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-practical-counter-example-a-synchronous-server"><a class="header" href="#a-practical-counter-example-a-synchronous-server">A practical counter-example: a synchronous server</a></h1>
<p>The benefits of asynchronous programming aren't immediately apparent to
everyone, and its understanding can be equally challenging. Therefore, we've
chosen to illustrate asynchronous programming with Miou through a counterexample
demonstrating its value: the implementation of a synchronous server. Our goal is
to then transform our synchronous server into an asynchronous one capable of
handling billions of connections simultaneously.</p>
<p>This tutorial presupposes that the reader is proficient in OCaml. While we aim
to provide comprehensive explanations of each step but we won't delve into basic
OCaml concepts.</p>
<p>The goal of this tutorial is to implement an "echo" server. This server simply
echoes back whatever the user sends to it. While this may seem straightforward,
several challenges arise, including the issue of synchronicity.</p>
<h2 id="socket"><a class="header" href="#socket">Socket</a></h2>
<p>To facilitate communication between a client and a server, we utilize sockets.
These are fundamental components provided by the system for handling
communication, and in OCaml, we can manipulate them effectively. Let's delve
deeper into their functionality.</p>
<p>A socket acts as an endpoint for communication, enabling two computers to
connect and exchange data. It follows a <em>client-server</em> model, where one side
initiates communication (the client), and the other side responds (the server).
In our example, we'll be focusing on implementing a server. To start, we need to
initialize a socket that's ready to accept connections.</p>
<pre><code class="language-ocaml">val socket : socket_domain -&gt; socket_type -&gt; int -&gt; file_descr
</code></pre>
<p>This function returns a file descriptor<sup class="footnote-reference"><a href="#file-descriptor">1</a></sup> representing the new
socket. Initially, this descriptor is "disconnected," meaning it's not yet set
up for reading or writing.</p>
<p>Several arguments are required, including the domain (determining whether the
socket communicates locally or over the Internet), the type of communication
(such as packet or stream communication), and the protocol used<sup class="footnote-reference"><a href="#unix-tutorial">2</a></sup>.
For our purposes, establishing a TCP/IP connection suffices. Thus, we create our
socket as follows:</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  ...
</code></pre>
<h2 id="establish-a-service"><a class="header" href="#establish-a-service">Establish a service</a></h2>
<p>After creating the socket, we need to assign a specific address to it so that it
can be reached from the network. This is done using the <code>bind</code> system call:</p>
<pre><code class="language-ocaml">val bind : file_descr -&gt; sockaddr -&gt; unit
</code></pre>
<p>Our address must consist of an IP and a port since we intend our socket to
communicate over the Internet. In OCaml, the <code>sockaddr</code> value represents this
address. For our server, we want it to be available on our local network at port
3000:</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr
</code></pre>
<p>Next, we specify that the socket can accept connections using the <code>listen</code>
system call:</p>
<pre><code class="language-ocaml">val listen : file_descr -&gt; int -&gt; unit
</code></pre>
<p>The <code>listen</code> function requires our file descriptor to begin accepting client
connections. It also needs a second argument, specifying the maximum number of
pending incoming connections. Our server not only handles incoming connections
but also echoes back what clients transmit. It's possible that a client may
want to connect simultaneously, so the system keeps these clients on hold until
we can manage the new incoming connection.</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64
</code></pre>
<p>With everything initialized, we can now handle incoming connections using the
<code>accept</code> syscall:</p>
<pre><code class="language-ocaml">val accept : file_descr -&gt; file_descr * sockaddr
</code></pre>
<p>This function will <strong>block</strong> until a new connection arrives. It returns a new
file descriptor representing the client along with its address. To communicate
with the client, we use this new file descriptor.</p>
<p>We're going to implement our client handler. Its goal is to read what the client
sends us and then echo it back. Transmitting bytes via a socket is done using
two functions:</p>
<pre><code class="language-ocaml">val read : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int
val write : file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int
</code></pre>
<p>These functions are <strong>blocking</strong> as well. The aim here is to store the bytes
received from the client to echo them back. We'll repeat this process as long as
we receive bytes from the client. Finally, we'll need to release our file
descriptor; we won't need it anymore. We'll use <code>Unix.close</code> to inform the
system that it can free all resources associated with this file descriptor.</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = Unix.read client buf 0 (Bytes.length buf) in
  if len = 0 then Unix.close client
  else let _ = Unix.write client buf 0 len in echo client
</code></pre>
<p>Now, let's complete the implementation of our service. This involves calling our
<code>echo</code> function with the file descriptor of our client as soon as we receive it.</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  let client, address_of_client = Unix.accept socket in
  echo client;
  Unix.close socket;
  print_endline "Server terminated"

let () = server ()
</code></pre>
<h3 id="compilation--usage"><a class="header" href="#compilation--usage">Compilation &amp; usage</a></h3>
<p>Let's start testing our program! We need to compile it first before we can use
it. A tool like <code>netcat</code>/<code>nc</code> is sufficient to act as a client:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;
[1] 4347
$ echo "Hello World"|netcat -q0 localhost 3000
Hello World
Server terminated
[1]  + 4347 done       ./a.out
</code></pre>
<p>Our server worked well! It handled only one client, but it correctly echoed back
what <code>netcat</code> sent to it (as seen in echo "Hello World"). It's also noteworthy
that the server terminated correctly. However, at this point, there are still
several aspects to describe.</p>
<h2 id="a-step-back"><a class="header" href="#a-step-back">A step back</a></h2>
<p>There are several concepts we need to clarify in this exercise that are crucial
when it comes to implementing a system and network application.</p>
<h3 id="synchronicity"><a class="header" href="#synchronicity">Synchronicity</a></h3>
<p>While it may be obvious to some, it's important to clarify this concept to fully
understand the following steps. If we review our code, we can describe what it
does:</p>
<ol>
<li>It creates a socket.</li>
<li>It defines an address.</li>
<li>It "binds" this socket to our address.</li>
<li>It instructs our system to make our socket available on the network.</li>
<li>It waits for a new connection.</li>
<li>It executes the <code>echo</code> function with our new incoming connection.</li>
<li>It displays "Server terminated".</li>
</ol>
<p>It's important to note that your system processes the program line by line, in
the order we wrote it. At each step, the system waits for the current line to
finish its execution before moving on to the next one. This is necessary because
each line depends on the work performed in the preceding lines.</p>
<p>This characteristic makes our program <strong>synchronous</strong>. Even if we introduce the
<code>echo</code> function, the program remains synchronous because the caller must wait
for the function to complete its task and return a value before continuing.</p>
<h3 id="blocking-function"><a class="header" href="#blocking-function">Blocking function</a></h3>
<p>Previously, we introduced the <code>accept</code> function, which waits for a connection to
arrive. It's worth noting that if no connection arrives, your program will wait
indefinitely! We say the function <strong>blocks</strong>, meaning it's waiting for an
external event (like the arrival of a client). And we can't do anything else as
long as this function is blocked. This type of function makes it impossible for
a program to carry out other computations while waiting for the former to
finish.</p>
<p>The reason for this is that OCaml programs are single-threaded<sup class="footnote-reference"><a href="#multicore">3</a></sup>. A
thread is a sequence of instructions that a program follows. Because the program
consists of a single thread, it can only do one thing at a time: so if it is
waiting for our long-running synchronous call to return, it can't do anything
else.</p>
<h2 id="handle-multiple-clients"><a class="header" href="#handle-multiple-clients">Handle multiple clients</a></h2>
<p>Our goal now is to handle more than one client. We could simply repeat our
<code>accept</code> call every time a client arrives.</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = Unix.read client buf 0 (Bytes.length buf) in
  if len = 0 then Unix.close client
  else let _ = Unix.write client buf 0 len in echo client

let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  while true do
    let client, address_of_client = Unix.accept socket in
    echo client
  done;
  Unix.close socket;
  print_endline "Server terminated"

let () = server ()
</code></pre>
<p>Let's try our code:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;
[1] 8592
$ echo "Hello World"|netcat -q0 localhost 3000
Hello World
$ echo "Hello World"|netcat -q0 localhost 3000
Hello World
$ kill -9 8592
[1]  + 8592 killed     ./a.out
</code></pre>
<p>It seems to work! However, let's try a specific scenario: when two clients try
to connect "at the same time". First, we'll launch a background client that will
simply connect, and then we'll launch another client that will attempt to send
some text.</p>
<pre><code class="language-shell">$ ./a.out &amp;
[1] 8711
$ netcat localhost 3000 &amp;
[2] 8728
[2]  + 8728 suspended (tty input)  netcat localhost 3000
$ echo "Hello World"|netcat -q0 localhost 3000
^C
$ kill -9 8728
$ kill -9 8711
</code></pre>
<p>Our second client, after our first one is connected, gets stuck. In reality,
when our first client connected, it made our server unavailable. This goes back
to our explanation of <strong>synchronicity</strong>: our program can strictly only do one
thing at a time. So, our program is currently handling our first client, and it
can't handle our second client until the first one is finished. In practice, our
<code>echo</code> function must finish so that our server can handle other clients.</p>
<h2 id="asynchronicity"><a class="header" href="#asynchronicity">Asynchronicity</a></h2>
<p>We're starting to see the fundamental problem of synchronicity in implementing a
system and network application: the ability for our service to respond to all
clients "at the same time." In our specific case, what we want is to be able to
background our <code>echo</code> function so that our server can wait for a new connection
again with <code>accept</code>. However, the concept of backgrounding a task is not so
straightforward:</p>
<ul>
<li>We know that we only have one <em>thread</em> available, so we can strictly only do
one thing. Which thread could execute our background task?</li>
<li>We know that some functions put us in a waiting state (waiting for a new
connection or waiting for data sent by the client). Instead of waiting, could
we seize this opportunity to do "something else"?</li>
<li>Ultimately, we primarily want to respond to events coming from the system.</li>
</ul>
<p>Several solutions exist for this. They vary even more depending on the language
used and what it can offer to address these issues. Regarding OCaml 5, two
elements can help us:</p>
<ul>
<li>Effects</li>
<li>Domains</li>
</ul>
<p>For the next chapter, we'll focus on effects and follow our second intuition.
Namely, taking the opportunity to do something else as soon as we're waiting for
an event such as the arrival of a connection with <code>accept</code>.</p>
<div class="footnote-definition" id="file-descriptor"><sup class="footnote-definition-label">1</sup>
<p>It is a unique identifier used by your system to represent
an input/output resource. In concrete terms, it's a non-negative integer that
serves as a reference to I/O channel within a process.</p>
</div>
<div class="footnote-definition" id="unix-tutorial"><sup class="footnote-definition-label">2</sup>
<p>These parameters may seem daunting for a newcomer. If you're
interested in delving deeper into system programming with OCaml and Unix, we
recommend checking out this <a href="https://ocaml.github.io/ocamlunix/index.html">tutorial</a>.</p>
</div>
<div class="footnote-definition" id="multicore"><sup class="footnote-definition-label">3</sup>
<p>The more curious will say that OCaml is "multicore", and that's
true. However, it is if you want to use the <code>Domain</code>/<code>Thread</code> module and
allocate a domain/thread that can do a task in parallel or concurrently. But
we'll explain all this in detail later.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-scheduler"><a class="header" href="#a-simple-scheduler">A simple scheduler</a></h1>
<p>In our previous chapter, we discussed the idea of backgrounding our <code>echo</code>
function to continue accepting incoming connections. Let's stick with the idea
of being able to background functions:</p>
<pre><code class="language-ocaml">let fn () = print_endline "World"

let () =
  do_this_in_background fn;
  print_endline "Hello"
</code></pre>
<p>Here, <code>do_this_in_background</code> would be a function that takes a task and adds it
to a kind of hidden to-do list. Instead of being literally synchronous and
waiting to display "World" before displaying "Hello", we could imagine directly
displaying "Hello" and letting <em>something</em> execute our <code>fn</code> function to display
"World".</p>
<p>This "something" is what we call a <strong>scheduler</strong>. It holds our list of tasks to
do and attempts to execute them all in a specific order. In our example, we
would notify our scheduler that a task <code>fn</code> needs to be done, display "Hello",
and then <em>wait</em> for our scheduler to complete all tasks (including displaying
"World").</p>
<p>In our explanation, we subtly introduced a new concept: waiting. In reality,
what we want is to wait for all our tasks to finish. To do this, we could have a
"witness" for our tasks so that we can wait for these tasks through their
witnesses:</p>
<pre><code class="language-ocaml">let fn () = print_endline "World"

let () =
  let witness = do_this_in_background fn in
  print_endline "Hello";
  await witness
</code></pre>
<p>We're starting to get closer to what every scheduler aims to provide and what
asynchronous programming is all about. Let's keep this example in mind and move
on to another concept necessary for implementing our scheduler.</p>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>Since OCaml 5, it has been possible to utilise effects. An effect allows you to
pause the execution of a function and enter a handler, which, depending on the
effect, would execute a specific operation to resume the paused function with
the result of that operation.</p>
<p>Here, we're delving into the flow of execution in your program. If we revisit
our definition of synchronicity, we understand that our system processes the
program line by line. However, effects (as well as exceptions) break this flow;
they're known for breaking the linear progression of execution. Consider the
example of an exception:</p>
<pre><code class="language-ocaml">exception My_exception

let () =
  try print_endline "Hello";
      raise My_exception;
      print_endline "World"
  with My_exception -&gt; print_endline "My_exception"
</code></pre>
<p>In this scenario, our code will print "Hello" and then trigger an exception.
Consequently, the subsequent line won't execute. Instead, this exception will be
"caught" by our handler <code>with ...</code>. This mechanism attempts to identify the
raised exception and, based on that, execute certain code — in our example,
printing "My_exception".</p>
<p>Raising exceptions or triggering an effect can be likened to a jump in our code.
The key distinction between an exception and an effect lies in the ability, for
the latter, to return to the point where the effect was initiated.</p>
<pre><code class="language-ocaml">open Effect.Deep

type _ Effect.t += My_effect : unit Effect.t

let run fn v =
  let rec retc x = x
  and exnc = raise
  and effc
    : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'b) option
    = function
    | My_effect -&gt;
      print_endline "My_effect";
      Some (fun k -&gt; continue k ())
    | _ -&gt; None
  and handler = { retc; exnc; effc; } in
  match_with fn v handler

let my_program () =
  print_endline "Hello";
  Effect.perform My_effect;
  print_endline "World"

let () = run my_program ()
</code></pre>
<p>The mechanics are a bit more intricate, but the principle remains consistent.
Upon executing the above code, we'll observe that we indeed enter our handler
(and display "My_effect" akin to using a <code>with ...</code> block for exceptions), but
we return to the precise point where the effect was initiated and then proceed
to display "World".</p>
<p>When considering our core challenge of implementing a scheduler, the utility of
effects becomes apparent in obtaining the value <code>k</code> as a representation of our
suspended function at a specific point — where we triggered our effect. For
managing tasks, with each task as a function, this <code>k</code> allows us to suspend and
resume functions, maintaining them in a suspended state in the background.</p>
<p>Indeed, for our scheduler, maintaining this suspension is crucial. Rather than
simply performing an operation and continuing with the result, we aim to:</p>
<ol>
<li>keep the suspension in background</li>
<li>allow other tasks to execute.</li>
<li>resume the suspension after giving the opportunity for other tasks to
execute.</li>
</ol>
<h2 id="a-task"><a class="header" href="#a-task">A task</a></h2>
<p>Now, we need to define what a task is. Earlier, we mentioned this value <code>k</code>,
which would represent a suspended state of our function. We could define what a
task is (an OCaml function) and in what state this task is:</p>
<ul>
<li>an initial state</li>
<li>a suspended state that can be resumed</li>
<li>a termination state</li>
</ul>
<pre><code class="language-ocaml">open Effect.Shallow

type 'a state =
  | Initial of (unit -&gt; 'a)
  | Suspended : ('c, 'a) continuation * 'c Effect.t -&gt; 'a state
  | Resolved of 'a
</code></pre>
<p>Just like with exceptions, we need to "attach" a handler to catch effects and
obtain that famous <code>k</code>. We can envision a generic handler that generates this
state from the effects produced by a function:</p>
<pre><code class="language-ocaml">let handler =
  let open Effect.Shallow in
  let retc v = Resolved v in
  let exnc = raise in
  let effc
    : type c. c Effect.t -&gt; ((c, 'a) continuation -&gt; 'b) option
    = fun eff -&gt; Some (fun k -&gt; Suspended (k, eff)) in
  { retc; exnc; effc }
</code></pre>
<p>Finally, we can define a task simply as our state.</p>
<pre><code class="language-ocaml">type task = Task : 'a state -&gt; task
</code></pre>
<p>At this stage, we have tasks, and it is now essential to define the operations
that we can perform with them. If we revisit our code from the very beginning,
which encapsulates the idea that we want to put tasks in the background, we
essentially perform two operations:</p>
<ul>
<li>we notify the scheduler of a new task (with our <code>do_this_in_background</code>).</li>
<li>we wait for our task with a witness of it.</li>
</ul>
<h2 id="a-promise"><a class="header" href="#a-promise">A promise</a></h2>
<p>This witness holds a term commonly found in asynchronous programming: a
<strong>promise</strong>. Indeed, this witness is a <em>promise</em> that our task will be executed
(but is not executed yet). Waiting for a task via its promise simply corresponds
to obtaining the result of our task. In our example, this result is <code>() : unit</code>
because we are merely displaying text, but we could easily imagine a hefty
computation (such as finding a prime number) that we would want to run in the
background.</p>
<p>In short, the promise would allow us to obtain this result. We could define it
as a mutable value that changes as soon as our task is completed:</p>
<pre><code class="language-ocaml">type 'a promise = 'a option ref
</code></pre>
<p>Now we can define our effects that will interact with our scheduler:</p>
<pre><code class="language-ocaml">type _ Effect.t += Spawn : (unit -&gt; 'a) -&gt; 'a promise Effect.t
type _ Effect.t += Await : 'a promise -&gt; 'a Effect.t
</code></pre>
<h2 id="our-scheduler"><a class="header" href="#our-scheduler">Our scheduler</a></h2>
<p>Our types are defined, and we know how to obtain them. Now, all we need to do is
implement our scheduler. As mentioned, the scheduler simply maintains a list of
tasks to be done. Therefore, it's a <code>task list</code> that we'll be manipulating. The
action of <code>Spawn</code> will enlarge this list, while <code>Await</code> will observe the state
of our promise, which will change as soon as its associated task is completed.
Waiting can result in two different situations:</p>
<ul>
<li>the case where, indeed, the promise has been resolved. In this case, we simply
transmit its result.</li>
<li>the case where it is not yet resolved. In this particular situation, we give
the opportunity for other tasks to execute (which can help in resolving our
initial task). This is referred to as <em>yielding</em>.</li>
</ul>
<pre><code class="language-ocaml">let perform
  : type c. task list ref -&gt; c Effect.t -&gt; [ `Continue of c | `Yield ]
  = fun todo -&gt; function
  | Spawn fn -&gt;
    let value = ref None in
    let task = Initial (fun () -&gt; value := Some (fn ())) in
    todo := !todo @ [ Task task ] ;
    `Continue value
  | Await value -&gt;
    begin match !value with
    | Some value -&gt; `Continue value
    | None -&gt; `Yield end
  | _ -&gt; invalid_arg "Invalid effect"
</code></pre>
<p>Finally, it's just a matter of iterating over this list to gradually complete
all our tasks. This iteration involves observing the state of each of our tasks.</p>
<ul>
<li>For the initial state, we simply launch the task and see what we obtain
through the handler we defined earlier (i.e., whether the task is resolved or
suspended).</li>
<li>For the resolved state, there's nothing to do; our task has finished.</li>
<li>Lastly, for the suspended state, we need to determine what operation our
effect produces (using <code>perform</code>). The case of yielding is interesting because
it involves keeping our suspension in our to-do list and attempting to execute
our other tasks first.</li>
</ul>
<pre><code class="language-ocaml">let step todo = function
  | Initial fn -&gt;
    Effect.Shallow.(continue_with (fiber fn) () handler)
  | Resolved v -&gt; Resolved v
  | Suspended (k, effect) -&gt;
    match perform todo effect with
    | `Continue v -&gt; Effect.Shallow.(continue_with k v handler)
    | `Yield -&gt; Suspended (k, effect)

let run fn =
  let result = ref None in
  let rec go = function
    | [] -&gt; Option.get !result
    | Task task :: rest -&gt;
      let todo = ref rest in
      match step todo task with
      | Resolved _ -&gt; go !todo
      | (Initial _ | Suspended _) as task -&gt; go (!todo @ [ Task task ]) in
  let task = Initial (fun () -&gt; result := Some (fn ())) in
  go [ Task task ]
</code></pre>
<h2 id="lets-play"><a class="header" href="#lets-play">Let's play!</a></h2>
<p>Have you kept in mind our initial code and our primary goal? It was about
putting a task in the background and executing it afterward. Returning to our
basic problem, we wanted to manage our clients as background tasks while
effectively handling the reception of new connections. Let's revisit the
original code:</p>
<pre><code class="language-ocaml">let fn () = print_endline "World"

let () =
  let witness = do_this_in_background fn in
  print_endline "Hello";
  await witness
</code></pre>
<p>With our scheduler, this code would become:</p>
<pre><code class="language-ocaml">let spawn fn = Effect.perform (Spawn fn)
let await prm = Effect.perform (Await prm)

let fn () = print_endline "World"

let () = run @@ fun () -&gt;
  let prm = spawn fn in
  print_endline "Hello";
  await prm
</code></pre>
<p>If we compile all of this and run the code, we get:</p>
<pre><code class="language-shell">$ ocamlopt main.ml
$ ./a.out
Hello
World
</code></pre>
<p>Et voilà! Our task displaying "World" was successfully put into the background,
and we indeed displayed "Hello" first. We now have the basics of our scheduler.
You now understand the core concepts of all schedulers (whether in OCaml or
JavaScript). Several (perhaps suboptimal) choices were made, but the most
important thing is to grasp the concept of asynchronous programming through a
concrete example.</p>
<p>Now, it's time to address our initial problem: managing our clients while also
accepting new connections. At this stage, you might think that simply "spawning"
our <code>echo</code> function will make it work in the background. However, even though
we've addressed the issue of synchronicity by offering an asynchronous library,
we deliberately overlooked mentioning <strong>blocking</strong> functions! That's what we'll
explore in our next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-the-system"><a class="header" href="#interacting-with-the-system">Interacting with the system</a></h1>
<p>In the implementation of our <code>echo</code> server, beyond the question of
synchronicity, there were also considerations about interactions with the system
and the resources it provides, such as sockets.</p>
<p>We noticed that to manage these resources, we had functions described as
"blocking", meaning they waited for specific events (such as a new client
connection) before proceeding. Apart from wanting to delegate tasks in the
background, we also aimed to leverage these situations to perform other tasks.</p>
<p>We have this opportunity with <code>Await</code>, which observes the state of our promise
and then decides to continue if it contains the result of our task or to "yield"
(i.e., execute other tasks) if the associated task is not yet complete.</p>
<p>We could reproduce the same approach for these blocking functions: continue if
they have an event to notify us about, or "yield" if we know they will block.
The crucial question then is to predict in advance whether they will block.
Fortunately, the system can provide us with this information.</p>
<h2 id="file-descriptors"><a class="header" href="#file-descriptors">File-descriptors</a></h2>
<p>In our first chapter, we introduced the concept of file descriptors. These are
system resources used to manage I/O operations such as handling client
connections, transmitting bytes, and more. It's essential to monitor the state
of these resources and determine beforehand whether functions like <code>accept()</code>
(for managing a new client) will block or not.</p>
<p>Typically, we can consider that all our functions interacting with the system
block by default. However, we can periodically check our active file descriptors
to determine if we can safely resume functions that will perform these blocking
system calls.</p>
<p>Monitoring the state of our active file descriptors and determining if an event
(which would unblock our functions) occurs is done using the <code>select()</code>
function:</p>
<pre><code class="language-ocaml">val select :
    file_descr list -&gt; file_descr list -&gt; file_descr list -&gt;
      float -&gt; file_descr list * file_descr list * file_descr list
</code></pre>
<p>This function takes several arguments, but only 3 are of interest to us. The
first and second arguments pertain to monitoring file descriptors that are
awaiting "read" and "write" operations, respectively. Typically, when we want to
wait for a client connection, we are waiting for a "read" operation on our file
descriptor. If we intend to transmit bytes to the client, we are waiting to be
able to "write" to our file descriptor. The last argument that concerns us is
the timeout for this observation. A reasonably short time is sufficient; let's
say 10ms.</p>
<p>For example, let's consider our <code>accept()</code> function. We want to determine
whether we should execute <code>accept()</code> without blocking:</p>
<pre><code class="language-ocaml">let rec our_accept file_descr =
  print_endline "Monitor our file-descriptor.";
  match Unix.select [ file_descr ] [] [] 0.01 with
  | [], _, _ -&gt; our_accept file_descr
  | file_descr :: _, _, _ -&gt; Unix.accept file_descr

let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  let client, sockaddr = our_accept socket in
  Unix.close client;
  Unix.close socket
</code></pre>
<p>Let's test this code and see what happens.</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; sleep 1; netcat -q0 localhost 3000
Monitor our file-descriptor.
Monitor our file-descriptor.
Monitor our file-descriptor.
...
[1]  + 6210 done       ./a.out
</code></pre>
<p>Testing this code reveals the repeated "Monitoring our file-descriptor."
messages until the program ends (after receiving a connection using <code>netcat</code>
after 1 second). What's interesting here is that instead of blocking on
<code>accept()</code>, we execute it only if <code>select()</code> informs us that our file descriptor
is indeed ready (meaning it has received an incoming connection). If not, we
retry the observation by calling <code>select()</code> again.</p>
<p>In more concrete terms, we are no longer in a situation where we indefinitely
wait for an event to unblock us, but rather we wait for just 10ms to retry an
observation or execute our <code>accept()</code> if ready. We've found a way to determine
in advance whether our function will block or not.</p>
<h2 id="integration-into-our-scheduler"><a class="header" href="#integration-into-our-scheduler">Integration into our scheduler</a></h2>
<p>Now, the advantage of <code>select()</code> is that it can observe <strong>multiple</strong> file
descriptors (not just one as in our example). Our goal is to provide an
<code>our_accept</code> function that doesn't block. In case our file descriptor isn't
ready (which is the default case, as a reminder, all our system functions
block), we'll reuse our <code>Await</code> to suspend the execution before actually
performing our <code>accept()</code>. This suspension will give us the opportunity to
execute other tasks.</p>
<pre><code class="language-ocaml">let waiting_fds_for_reading = Hashtbl.create 0x100

let our_accept file_descr =
  let value = ref None in
  Hashtbl.add waiting_fds_for_reading file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_reading file_descr;
  Unix.accept file_descr
</code></pre>
<p>Finally, periodically, we'll observe all the file descriptors that are waiting.
<code>select()</code> will inform us about those that can be unblocked. We just need to
<em>fulfill</em> our promise so that our scheduler can resume our suspended function.</p>
<pre><code class="language-ocaml">let fullfill tbl fd =
  let value = Hashtbl.find tbl fd in
  value := Some ()

let our_select () =
  let rds = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_reading) in
  let rds, _, _ = Unix.select rds [] [] 0.01 in
  List.iter (fullfill waiting_fds_for_reading) rds
</code></pre>
<p>Ultimately, we just need to call <code>our_select()</code> periodically. We previously
mentioned that our scheduler tries to resolve our tasks step by step. We'll
interleave these steps with this observation. This way, we'll be almost
immediately aware of the occurrence of events (within 10ms and a snippet of a
task execution).</p>
<pre><code class="language-ocaml">let run fn =
  let result = ref None in
  let rec go = function
    | [] -&gt; Option.get !result
    | Task task :: rest -&gt;
        let todo = ref rest in
        let todo =
          match step todo task with
          | Resolved _ -&gt; !todo
          | (Initial _ | Suspended _) as task -&gt; !todo @ [ Task task ]
        in
        our_select (); go todo
  in
  let task = Initial (fun () -&gt; result := Some (fn ())) in
  go [ Task task ]
</code></pre>
<h2 id="lets-try"><a class="header" href="#lets-try">Let's try!</a></h2>
<p>Let's revisit our example with <code>accept()</code>:</p>
<pre><code class="language-ocaml">let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  let client, sockaddr = our_accept socket in
  Unix.close client;
  Unix.close socket

let () = run server
</code></pre>
<p>If we execute our server with our scheduler:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; netcat -q0 localhost 3000
[1] 38255
[1]  + 38255 done       ./a.out
</code></pre>
<p>We notice that our program does not indefinitely block. It only blocks
periodically for 10ms<sup class="footnote-reference"><a href="#busy-loop">1</a></sup> and observes the active file descriptors (in
our <code>waiting_fds_for_reading</code> table). Finally, as soon as <code>netcat</code> connects, we
can resume our <code>our_accept</code> function and continue executing our program. With
the ability to put tasks in the background, we can now attempt to reimplement
our server asynchronously. However, we need to provide, just like <code>our_accept</code>,
<code>our_read</code> and <code>our_write</code>. The first one will reuse our
<code>waiting_fds_for_reading</code> table, while the second one will use a new table to
determine if our file descriptors are ready to transmit bytes.</p>
<pre><code class="language-ocaml">let our_read file_descr buf off len =
  let value = ref None in
  Hashtbl.add waiting_fds_for_reading file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_reading file_descr;
  Unix.read file_descr buf off len

let waiting_fds_for_writing = Hashtbl.create 0x100

let our_write file_descr buf off len =
  let value = ref None in
  Hashtbl.add waiting_fds_for_writing file_descr value;
  Effect.perform (Await value);
  Hashtbl.remove waiting_fds_for_writing file_descr;
  Unix.write file_descr buf off len

let our_select () =
  let rds = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_reading) in
  let wrs = List.of_seq (Hashtbl.to_seq_keys waiting_fds_for_writing) in
  let rds, wrs, _ = Unix.select rds wrs [] 0.01 in
  List.iter (fullfill waiting_fds_for_reading) rds;
  List.iter (fullfill waiting_fds_for_writing) wrs
</code></pre>
<p>Now, we can both await new connections and manage in background our clients:</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = our_read client buf 0 (Bytes.length buf) in
  if len = 0 then Unix.close client
  else let _ = our_write client buf 0 len in echo client

let server () =
  let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Unix.bind socket sockaddr;
  Unix.listen socket 64;
  while true do
    let client, address_of_client = our_accept socket in
    ignore (spawn @@ fun () -&gt; echo client)
  done;
  Unix.close socket;
  print_endline "Server terminated"

let () = run server
</code></pre>
<p>To test this code, simply launch your server and run 2 <code>netcat</code> instances
simultaneously (in 2 different terminals). You'll notice that our server no
longer blocks and can handle these 2 clients "simultaneously". We have finally
succeeded in creating an asynchronous server with effects in OCaml.</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package unix main.ml
$ ./a.out &amp;; \
  echo "Salut"|netcat -q0 localhost 3000; \
  echo "Hello"|netcat -q0 localhost 3000
[1] 40381
Salut
Hello
$ kill -9 40381
[1]  + 40381 killed     ./a.out
</code></pre>
<p>At this point, all the basic concepts of a scheduler and asynchronous
programming have been explained. It's time to take a look back at what we've
learned and, most importantly, start comparing it with Miou in the next chapter.</p>
<div class="footnote-definition" id="busy-loop"><sup class="footnote-definition-label">1</sup>
<p>The purpose of the 10ms interval is to prevent our program from
falling into what is known as a <a href="https://en.wikipedia.org/wiki/Busy_waiting">"busy-loop"</a>. Indeed, these 10ms
intervals notify our system that our program will do nothing during this time
period unless an event occurs. Our system is then able to put our program to the
<em>sleep</em> mode and also take the opportunity to do something else. What is certain
is that this <em>sleep</em> mode allows our program not to monopolize the processor. In
the case of a "busy-loop," our program would be the only one able to run, and
you would likely hear your processor fan whirring loudly.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retrospective"><a class="header" href="#retrospective">Retrospective</a></h1>
<p>At this stage, you're familiar with all the concepts of a scheduler,
asynchronous programming, and interactions with the system. Of course, as you
might suspect, we've omitted a whole bunch of details, and Miou offers much more
than our simple scheduler. However, at this point, we can describe in detail
what Miou brings to the table (including its subtleties). That's what we'll
explore in this chapter.</p>
<h2 id="a-task-as-a-resource"><a class="header" href="#a-task-as-a-resource">A task as a resource</a></h2>
<p>Let's revisit our example with the <code>echo</code> server, where we aimed to handle
client management in the background:</p>
<pre><code class="language-ocaml">    ignore (spawn @@ fun () -&gt; echo client)
</code></pre>
<p>You can achieve the same thing with <code>Miou.call_cc</code>. This function essentially
does will more what our <code>spawn</code> does: it creates a new task that will run on the
same <em>thread</em> using our scheduler. This type of task which coexists with others
on the same thread is called a <em><a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">fiber</a></em>. And, just like <code>spawn</code>,
<code>Miou.call_cc</code> also returns a promise for this task. In Miou, you're creating a
child of your task, a subtask.</p>
<p>The key difference with Miou, though, is that you can't forget your children!</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  ignore (Miou.call_cc @@ fun () -&gt; print_endline "Hello World!")
Exception: Miou.Still_has_children.
</code></pre>
<p>In Miou, we treat a task as a resource. You allocate it (using <code>Miou.call_cc</code>),
but you also have to release it with <code>Miou.await</code>. A fundamental rule governs
Miou programs: all tasks must either be awaited or canceled. Forgetting a task
will result in a fatal error.</p>
<h3 id="background-tasks"><a class="header" href="#background-tasks">Background tasks</a></h3>
<p>This brings up another question: what should we do with our subtasks that manage
clients? If this rule exists, it's because these children can misbehave. And you
need to be notified of these abnormal situations. What matters isn't the
existence of these tasks (since your goal is to put them in the background) but
their results to ensure everything went well.</p>
<p>In this regard, Miou offers a way to save your tasks somewhere and retrieve them
once they're completed. This is mainly done using the <code>orphans</code> value:</p>
<pre><code class="language-ocaml">let rec clean_up orphans = match Miou.care orphans with
  | None | Some None -&gt; ()
  | Some (Some prm) -&gt;
    match Miou.await prm with
    | Ok () -&gt; clean_up orphans
    | Error exn -&gt; raise exn

let server () =
  ...
  let orphans = Miou.orphans () in
  while true do
    clean_up orphans;
    let client, address_of_client = Miou_unix.accept socket in
    ignore (Miou.call_cc ~orphans @@ fun () -&gt; echo client)
  done
</code></pre>
<p>The advantage of this approach is that it treats a task as a resource that must
be released at some point in your program's execution. Our experience in
implementing protocols at <a href="https://robur.coop/">Robur</a> has convinced us of the importance of
not forgetting about our children. Developing system and network applications
involves creating programs with long execution time (6 months, 1 year, etc.).
Tasks consume memory and possibly processor resources. Forgetting tasks can lead
to memory leaks, which can hinder your program's long-term viability (the
system might terminate your program due to an <a href="https://fr.wikipedia.org/wiki/Out_of_memory">out-of-memory</a> error).</p>
<h2 id="structured-concurrency"><a class="header" href="#structured-concurrency">Structured concurrency</a></h2>
<p>Managing tasks and their promises can be a real challenge when implementing a
large application. Indeed, conceptualizing tasks running in the background
leaves room for practices (like forgetting these tasks) that can lead to
significant maintenance overhead in the long run. At Robur, through certain
projects we maintain, we've encountered situations where the time to fix bugs
becomes disproportionately large given our resources because we need to
re-establish the mental model of task management, which isn't all that obvious.</p>
<p>Thus, when developing Miou, it was essential from the outset to establish rules
to prevent repeating past mistakes. We've already introduced one rule: never
forget your children.</p>
<p>There's a second rule: only the <strong>direct</strong> parent can wait for or cancel its
children. For instance, the following code is incorrect:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let a = Miou.call_cc @@ fun () -&gt; Miou.yield () in
  let b = Miou.call_cc @@ fun () -&gt; Miou.await_exn a in
  Miou.await_exn a;
  Miou.await_exn b
Exception: Miou.Not_a_child.
</code></pre>
<p>The purpose of such a constraint is to maintain a simple mental model of the
active tasks in your application: their affiliations form a tree with the root
being your main task (the one launched with <code>Miou.run</code>). Therefore, if your main
task terminates, it invariably means that all sub-tasks have also terminated.</p>
<h2 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h2>
<p>One aspect deliberately left out in the implementation of our small scheduler is
cancellation. It can be useful to cancel a task that, for example, is taking too
long. Miou provides this mechanism for all tasks using their promises.</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let prm = Miou.call_cc @@ fun () -&gt; print_endline "Hello World" in
  Miou.cancel prm
</code></pre>
<p>The rules of parentage explained earlier also apply to cancellation. You can
only cancel your direct children:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let a = Miou.call_cc @@ fun () -&gt; Miou.yield () in
  let b = Miou.call_cc @@ fun () -&gt; Miou.cancel a in
  Miou.await_exn a;
  Miou.await_exn b
Exception: Miou.Not_a_child.
</code></pre>
<p>Cancellation overrides any promise state. You can cancel a task that has already
completed. In this case, we lose the result of the task, and it's considered
canceled:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let prm = Miou.call @@ fun () -&gt; 1 + 1 in
  let _ = Miou.await prm in
  Miou.cancel prm;
  match Miou.await prm with
  | Ok _ -&gt; assert false
  | Error Miou.Cancelled -&gt; assert true
  | Error exn -&gt; raise exn
</code></pre>
<p>Of course, to be consistent with our other rules, canceling a task implies
canceling all its sub-tasks:</p>
<pre><code class="language-ocaml">let rec infinite () = infinite (Miou.yield ())

let () = Miou.run @@ fun () -&gt;
  let p = Miou.call_cc @@ fun () -&gt;
    let q = Miou.call infinite in
    Miou.await_exn q in
  Miou.cancel p
</code></pre>
<p>Lastly, let's delve into the behavior of <code>Miou.cancel</code>. It's said that this
function is <em>asynchronous</em> in the sense that cancellation (especially that of a
task running in parallel) may take some time. Thus, Miou seizes the opportunity
to execute other tasks during this cancellation. For example, note that <code>p0</code>
runs despite the cancellation of <code>p1</code>:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let p1 = Miou.call @@ fun () -&gt; Miou.yield () in
  let v = ref false in
  let p0 = Miou.call_cc @@ fun () -&gt; print_endline "Do p0" in
  print_endline "Cancel p1";
  Miou.cancel p1;
  print_endline "p1 cancelled";
  Miou.await_exn p0
</code></pre>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package miou main.ml
$ ./a.out
Cancel p1
Do p0
p1 is cancelled
</code></pre>
<p>The advantage of this asynchronicity is to always be able to handle system
events even if we attempt to cancel a task.</p>
<h2 id="multiple-domain-runtime"><a class="header" href="#multiple-domain-runtime">Multiple domain runtime</a></h2>
<p>In the introduction, it was mentioned that it's possible to use multiple domains
with Miou. Indeed, since OCaml 5, it has been possible to launch functions in
parallel. This parallelism has become possible only recently because these
functions have their own <em>minor heap</em>. Thus, synchronization between domains
regarding allocation and garbage collection is less systematic.</p>
<p>To launch a task in parallel with Miou, it's sufficient to use:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let prm = Miou.call @@ fun () -&gt;
    print_endline "My parallel task." in
  Miou.await_exn prm
</code></pre>
<p>Miou takes care of allocating multiple domains according to your system's
specifics. These domains will be waiting for tasks, and <code>Miou.call</code> notifies
them of a new task to perform. Just like <code>Miou.call_cc</code>, <code>Miou.call</code> also
returns a promise, and the same rules apply: you must not forget about your
children.</p>
<p>A task in parallel explicitly means that it will run in a different domain than
the one it was created in. That is, this code, which returns the domain in which
the task is executing, is always true:</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let p =
    Miou.call @@ fun () -&gt;
    let u = Stdlib.Domain.self () in
    let q = Miou.call @@ fun () -&gt; Stdlib.Domain.self () in
    (u, Miou.await_exn q)
  in
  let u, v = Miou.await_exn p in
  assert (u &lt;&gt; v)
</code></pre>
<p>However, the choice of the domain responsible for the task is made randomly.
Thus, this code is also true (meaning that two tasks launched in succession
can then use the same domain):</p>
<pre><code class="language-ocaml">let () = Miou.run @@ fun () -&gt;
  let assertion = ref false in
  while !assertion = false do
    let p = Miou.call @@ fun () -&gt; Stdlib.Domain.self () in
    let q = Miou.call @@ fun () -&gt; Stdlib.Domain.self () in
    let u = Miou.await_exn p in
    let v = Miou.await_exn q in
    assertion := u = v
  done
</code></pre>
<p>It may happen then that we want to distribute a specific task to all our
available domains. We cannot do this with <code>Miou.call</code>, which may, several times,
assign the same domain for a task. However, Miou offers a way to distribute the
workload evenly across all your domains:</p>
<pre><code class="language-ocaml">let task () : int = (Stdlib.Domain.self () :&gt; int)

let () = Miou.run ~domains:3 @@ fun () -&gt;
  let domains =
    Miou.parallel task (List.init 3 (Fun.const ()))
    |&gt; List.map Result.get_ok in
  assert (domains = [1; 2; 3])
</code></pre>
<p>Finally, one last rule exists regarding parallel tasks. There may be a situation
called starvation. Indeed, like your number of cores, the number of domains is
limited. It may happen that domains wait for each other, but it's certain that
the main domain (the very first one that executes your code, known as <code>dom0</code>)
will never be assigned a task via <code>Miou.call</code>.</p>
<p>This rule prevents a domain from waiting for another domain, which waits for
another domain, which waits for <code>dom0</code>, which waits for your first domain - the
<a href="https://en.wikipedia.org/wiki/Starvation_(computer_science)">starvation problem</a>. Thus, it may happen that <code>dom0</code> is no longer
involved in the execution of your program and is only waiting for the other
domains. However, we can involve it using <code>Miou.call_cc</code>:</p>
<pre><code class="language-ocaml">let task () : int = (Stdlib.Domain.self () :&gt; int)

let () = Miou.run ~domains:3 @@ fun () -&gt;
  let prm = Miou.call_cc my_super_task in
  let domains =
    Miou.await prm
    :: Miou.parallel task (List.init 3 (Fun.const ())) in
  let domains = List.map Result.get_ok domains in
  assert (domains = [0; 1; 2; 3])
</code></pre>
<p>However, we would like to warn the user. Parallelizing a task doesn't
necessarily mean that your program will be faster. Once again, Miou focuses
essentially on managing system events. Domains are equally subject to observing
these events, which means that all computations are interleaved with this
observation (and can therefore have an impact on performance).</p>
<p>Having more domains is not a solution for performance either. If Miou takes care
of allocating (as well as releasing) domains, it's because they require a lot of
resources (such as a minor-heap). Thus, the domains are available, but it's Miou
that manages them.</p>
<p>Finally, Miou mainly aims to facilitate the use of these domains, especially
regarding inter-domain synchronization. Indeed, tasks as well as their promises
concerning <code>Miou.call</code> do not exist in the same domains. An internal mechanism
helps the user not to worry about the synchronicity between the task's state and
its promise, even though they exist in two spaces that run in parallel.</p>
<h2 id="for-the-next-steps"><a class="header" href="#for-the-next-steps">For the next steps</a></h2>
<p>This retrospective allows us to introduce the basic elements of Miou. We now
need to see how to use Miou and also introduce you to some new concepts. The
next chapter will consist of re-implementing our echo server with Miou. There
should be only a few differences, but we will seize the opportunity to improve
our server, especially with the use of parallel tasks and the notion of
ownership.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-echo-server-with-miou"><a class="header" href="#an-echo-server-with-miou">An echo server with Miou</a></h1>
<p>Passer de notre petit scheduler à Miou est assez simple. Mise à part la règle
de ne pas oublier ses enfants que nous avons introduit dans le chapitre précédent,
il s'agit principalement d'utiliser <code>Miou</code> et <code>Miou_unix</code>. Prennons la fonction
<code>echo</code> qui gère nos clients:</p>
<p>Moving from our custom scheduler to Miou is quite straightforward. Apart from
the rule of not forgetting our children that we introduced in the previous
chapter, it mainly involves using <code>Miou</code> and <code>Miou_unix</code>. Let's take the <code>echo</code>
function that handles our clients:</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = Miou_unix.read client buf 0 (Bytes.length buf) in
  if len = 0 then Miou_unix.close client
  else
    let str = Bytes.sub_string buf 0 len in
    let _ = Miou_unix.write client str 0 len in echo client
</code></pre>
<p>A subtlety lies in <code>Miou_unix.write</code>, which expects a <code>string</code> instead of
<code>bytes</code>. In a concurrent execution, it may happen that <code>buf</code> could be modified
concurrently. Using a <code>string</code> ensures that the buffer we want to transmit does
not change in the meantime. Once again, this comes from our experience in
protocol implementation.</p>
<p>Then, according to the rules introduced in the previous chapter, we need to
re-implement our server so that it uses an <code>orphans</code> value and periodically
<em>cleans up</em> our terminated clients to avoid forgetting our children:</p>
<pre><code class="language-ocaml">let clean_up orphans = match Miou.care orphans with
  | None | Some None -&gt; ()
  | Some (Some prm) -&gt; match Miou.await prm with
    | Ok () -&gt; ()
    | Error exn -&gt; raise exn

let server () =
  let socket = Miou_unix.tcpv4 () in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Miou_unix.bind_and_listen socket sockaddr;
  let orphans = Miou.orphans () in
  while true do
    clean_up orphans;
    let client, _ = Miou_unix.accept socket in
    ignore (Miou.call_cc ~orphans (fun () -&gt; echo client))
  done;
  Miou_unix.close socket

let () = Miou_unix.run server
</code></pre>
<p>Note the use of <code>Miou_unix.run</code> to handle system events and the functions from
this module. For more details, we will explain the interactions between the
system and Miou more precisely in the next chapter.</p>
<p>And there we go, we've switched to Miou! All we need to do is compile our
project like this:</p>
<pre><code class="language-shell">$ opam install miou
$ ocamlfind opt -linkpkg -package miou,miou.unix main.ml
$ ./a.out &amp;
[1] 436169
$ echo "Hello" | netcat -q0 localhost 3000
Hello
$ kill -9 436169
[1]  + 436169 killed     ./a.out
</code></pre>
<h2 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h2>
<p>Since it's now possible to utilise multiple domains, let's take advantage of
this to instantiate more than one server. Indeed, it's conceivable that multiple
servers could exist at the same address (<code>localhost:3000</code>). In such a scenario,
it's first come, first served. Therefore, we can envision managing multiple
servers in parallel, each handling several clients concurrently.</p>
<p>To distribute the implementation of our server across multiple domains, we'll
use <code>Miou.parallel</code>. We won't forget to involve <code>dom0</code> (referring to our rule
where <code>dom0</code> would never be assigned a task from other domain) via
<code>Miou.call_cc</code>:</p>
<pre><code class="language-ocaml">let () = Miou_unix.run @@ fun () -&gt;
  let domains = Stdlib.Domain.recommended_domain_count () - 1 in
  let domains = List.init domains (Fun.const ()) in
  let prm = Miou.call_cc server in
  Miou.await prm :: Miou.parallel server domains
  |&gt; List.iter @@ function
  | Ok () -&gt; ()
  | Error exn -&gt; raise exn
</code></pre>
<p>To ensure that we're leveraging the full potential of our machine, we can check
how many threads our program has (note that an OCaml domain always has 2
threads!). Thus, for a system with 32 cores:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package miou,miou.unix main.ml
$ ./a.out &amp;
[1] 438053
$ ls /proc/438053/task | wc -l
64
$ kill -9 438053
[1]  + 438053 killed     ./a.out
</code></pre>
<p>Almost for free, we've managed to launch multiple servers in parallel!</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>When it comes to building system and network applications, we often deal with
resources shared between the application and the system. One such resource we
use here is the file descriptor. OCaml has the advantage of offering a garbage
collector to handle memory management for us. However, we still need to consider
releasing system resources, particularly file descriptors.</p>
<p>Another point to consider is the manipulation of these resources. We subtly
mentioned, using <code>Miou_unix.write</code>, the possibility that a buffer could be
concurrently modified. From our experience, the concept of resource ownership
(like a buffer) specific to a particular task is lacking in OCaml and can lead
to rather challenging bugs to identify and understand. In this regard, languages
like Rust offer solutions that can help developers avoid a resource being
manipulated by two tasks "at the same time". The problem is even more
significant with tasks that can run in parallel. This is referred to as a
<a href="https://en.wikipedia.org/wiki/Race_condition">data race</a>.</p>
<p>Therefore, the best we can offer, Miou provides resource management that
resembles that of Rust: a task has exclusive access to a resource once it has
"proof" of ownership.</p>
<p>Miou offers an API, <code>Miou.Ownership</code>, where you can:</p>
<ul>
<li>Create proof of ownership</li>
<li>Own a resource through this proof</li>
<li>Disown a resource through this proof</li>
<li>Transfer this resource to a child via this proof</li>
<li>Transfer this resource to the parent via this proof</li>
<li>Verify, before manipulating this resource, that you have exclusive access to
it</li>
</ul>
<p><code>Miou_unix</code> extends this API to file descriptors. In this second part of this
chapter, it's essential to ensure that we are indeed the owners of the file
descriptor we are manipulating. This won't change the behavior of our server; it
just allows us to sleep better tonight!</p>
<p>Let's start with the <code>echo</code> function:</p>
<pre><code class="language-ocaml">let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = Miou_unix.Ownership.read client buf 0 (Bytes.length buf) in
  if len = 0 then Miou_unix.Ownership.close client
  else
    let str = Bytes.sub_string buf 0 len in
    let _ = Miou_unix.Ownership.write client str 0 len in echo client
</code></pre>
<p><code>Miou_unix.Ownership.{read,write}</code> perform the necessary checks, while
<code>Miou_unix.Ownership.close</code> disown our file descriptor since we no longer need
it. Forgetting this step would result in an error in your application, and Miou
would notify you that a resource has been forgotten (via
<code>Miou.Resource_leaked</code>). Once attached to a task, a resource must be transferred
or released; otherwise, it's considered forgotten! The aim is truly to assist
the developer in not forgetting anything they manipulate.</p>
<p>Another interesting aspect of resources is the case of an abnormal termination
of our <code>echo</code> function via an exception. A resource is also associated with a
<em>finalizer</em> that will be executed if the task in possession of the resource
terminates abnormally. Again, the goal is to sleep well tonight.</p>
<p>Now, let's move on to our <code>server</code> function, where we need to transfer our
client file descriptor to our <code>echo</code> task:</p>
<pre><code class="language-ocaml">let server () =
  let socket = Miou_unix.Ownership.tcpv4 () in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Miou_unix.Ownership.bind_and_listen socket sockaddr;
  let orphans = Miou.orphans () in
  while true do
    clean_up orphans;
    let client, _ = Miou_unix.Ownership.accept socket in
    ignore (Miou.call_cc
      ~give:[ Miou_unix.Ownership.resource client ]
      ~orphans (fun () -&gt; echo client))
  done;
  Miou_unix.Ownership.close socket
</code></pre>
<p>And there you have it! Assuming everything goes well, our code is correct, and
we are using our resources correctly. The <code>Miou.Ownership</code> module is not
mandatory in Miou's usage but provides a value to dynamically verify the proper
use and transfer of your resources. While it's not obligatory, we strongly
recommend using it.</p>
<p>The <em>finalizer</em> associated with the resource can also be genuinely beneficial,
especially when cancellation occurs: it ensures there are no leaks, even in
abnormal situations.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>If you've made it this far, you've likely seen a good portion of what Miou has
to offer and delved into the intricacies of asynchronous programming and system
interactions. You can continue experimenting and having fun with Miou or delve
deeper into our tutorial.</p>
<p>If you recall our initial challenge with our <code>echo</code> server, we divided the
subject into two parts: the scheduler and system interactions. Miou also
maintains this separation between the <code>Miou</code> module and the <code>Miou_unix</code> module.
The next chapter will revisit system interactions, but this time with Miou. The
goal will be to implement <em>sleepers</em> (and replicate <code>Unix.sleep</code>).</p>
<p>Finally, the last chapter is an enhancement of our <code>echo</code> server using Mutexes
and Conditions provided by Miou. This chapter explains in detail the benefits of
using these modules over those offered by OCaml and presents, once again, a
concrete case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-the-system-with-miou"><a class="header" href="#interacting-with-the-system-with-miou">Interacting with the system with Miou</a></h1>
<p>Miou is structured similarly to our small scheduler, but with a clear
distinction between scheduling and system interaction.</p>
<p>The goal is to be able to inject a certain type of interaction based on the
system used, which may not necessarily be <code>Unix</code>. As mentioned in the
introduction, our cooperative also aims to implement services as unikernels.
These are very specific systems where the concept of files may not even exist.
In this sense, <code>Miou_unix</code> is specific to <code>Unix</code>.</p>
<p><code>Unix</code> and <code>Miou_unix</code> may suffice for most use cases. However, they may not be
suitable for unikernels and may not meet your criteria and system requirements.
A system like Linux may offer alternative means such as <code>epoll()</code> for
interacting with the external world, for example.</p>
<p>Beyond other possibilities, subtle differences may also exist. Indeed, systems
like Linux or *BSD may not necessarily offer the same semantics in their
handling of TCP/IP connections, for instance. These nuances make it difficult
and even <em>error-prone</em> to try to standardize all these interactions. Overall, we
believe that you are the best person to know how to interact with the system. As
such, we offer this small tutorial to guide you on how to implement the <em>glue</em>
between Miou and your system.</p>
<h2 id="sleepers"><a class="header" href="#sleepers">Sleepers</a></h2>
<p>One of the simplest interactions we can implement with Miou is the <em>sleeper</em>.
It's akin to what <code>Unix.sleep</code> does: waiting for a certain amount of time. We'll
iterate through its implementation to:</p>
<ul>
<li>Start by offering such a function.</li>
<li>Handle the scenario where multiple domains might use this function.</li>
<li>Finally, manage the cancellation of tasks that have called this function.</li>
</ul>
<p>To guide our tutorial, here's the code we aim to execute. The module <code>Chat</code> is
the one we need to implement.</p>
<pre><code class="language-ocaml">let program () =
  Chat.run @@ fun () -&gt;
  let a = Miou.call_cc @@ fun () -&gt; Chat.sleep 1. in
  let b = Miou.call_cc @@ fun () -&gt; Chat.sleep 2. in
  Miou.await_all [ a; b ]
  |&gt; List.iter @@ function
  | Ok () -&gt; ()
  | Error exn -&gt; raise exn

let () =
  let t0 = Unix.gettimeofday () in
  program ();
  let t1 = Unix.gettimeofday () in
  assert (t1 -. t0 &lt; 3.)
</code></pre>
<p>If we assume that tasks run "simultaneously," this program should execute in
less than 3 seconds.</p>
<h2 id="our-sleeper-function"><a class="header" href="#our-sleeper-function">Our sleeper function</a></h2>
<p>If you remember from our little scheduler, we reused our <code>Await</code> effect to
implement our <code>our_accept</code> function. We then injected our <code>our_select</code> into our
scheduler so that it could observe events and signal suspension points to resume
them.</p>
<p>Similarly, Miou offers such mechanisms. You can suspend a function using a
unique identifier called <code>Miou.syscall</code>:</p>
<pre><code class="language-ocaml">type syscall
type uid = private int [@@immediate]

val syscall : unit -&gt; syscall
val uid : syscall -&gt; uid
val suspend : syscall -&gt; unit
</code></pre>
<p>The equivalent of our <code>Effect.perform (Await prm)</code> from our little scheduler
would be <code>Miou.suspend</code>. Therefore, our main goal is to save our syscall
<em>somewhere</em> and attach the time we need to wait to it:</p>
<pre><code class="language-ocaml">type sleeper =
  { time : float
  ; syscall : Miou.syscall }

module Sleepers = Miou.Pqueue.Make (struct
  type t = sleeper

  let compare { time= a; _ } { time= b; _ } = Float.compare a b
  let dummy = { time= 0.0; syscall= Obj.magic () }
end)

let sleepers = Sleepers.create ()

let sleep delay =
  let time = Unix.gettimeofday () +. delay in
  let syscall = Miou.syscall () in
  Sleepers.insert { time; syscall } sleepers;
  Miou.suspend syscall
</code></pre>
<p>Using a priority queue<sup class="footnote-reference"><a href="#proof">1</a></sup> will allow us to get the syscall that needs to
resume its function as soon as possible among all our sleepers.</p>
<p>Now we need to find a way to inject a function that will be called periodically,
in which we can resume our functions just like we did for our little scheduler
with our <code>our_select</code> function. Fortunately, Miou offers this possibility of
injecting such a function via <code>Miou.run</code>:</p>
<pre><code class="language-ocaml">type select = block:bool -&gt; uid list -&gt; signal list
type events = { select: select; interrupt: unit -&gt; unit }

val run : ?events:(Domain.Uid.t -&gt; events) -&gt; (unit -&gt; 'a) -&gt; 'a
</code></pre>
<p>At the very beginning, Miou tries to allocate the domains. For each domain, it
will ask for an <code>event</code> value that contains a <code>select</code> function. This is the
function we need to implement and provide to Miou. This function will be called
whenever there is a syscall after executing a portion of our tasks and
periodically. This function must return signals allowing Miou to resume
functions that have been suspended by our syscalls.</p>
<pre><code class="language-ocaml">type signal

val signal : syscall -&gt; signal
</code></pre>
<p>So, one of its goals is to determine if one of our sleepers should resume one of
our tasks or not.</p>
<pre><code class="language-ocaml">let in_the_past ts = ts = 0. || ts &lt;= Unix.gettimeofday ()

let rec remove_and_signal_older sleepers acc =
  match Sleepers.find_min sleepers with
  | None -&gt; acc
  | Some { time; syscall } when in_the_past time -&gt;
    Sleepers.delete_min_exn sleepers;
    remove_and_signal_older sleepers (Miou.signal syscall :: acc)
  | Some _ -&gt; acc

let select ~block:_ _ =
  let ts = match Sleepers.find_min sleepers with
    | None -&gt; 0.0
    | Some { time; _ } -&gt;
      let value = time -. Unix.gettimeofday () in
      Float.max 0.0 value in
  Unix.sleepf ts;
  remove_and_signal_older sleepers []

let events _ = { Miou.select; interrupt= ignore }
let run fn = Miou.run ~events fn
</code></pre>
<p>As you can see, we are specializing our <code>Miou.run</code> function with our <code>events</code>.
That's why whenever you use functions from <code>Miou_unix</code>, for example, you should
use <code>Miou_unix.run</code>. Let's now try our code:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package miou,unix -c chat.ml
$ ocamlfind opt -linkpkg -package miou,unix chat.cmx main.ml
$ ./a.out
$ echo $?
0
</code></pre>
<p>And there you go! We've just proven that our two tasks are running concurrently.
Note the use of <code>Unix.sleepf</code> instead of <code>Unix.select</code>. Here, we are only
interested in waiting rather than observing our file descriptors.</p>
<h2 id="domains--system"><a class="header" href="#domains--system">Domains &amp; system</a></h2>
<p>As mentioned earlier, Miou manages multiple domains. Therefore, if our <code>select</code>
function uses a global variable like <code>sleepers</code>, we will definitely encounter an
access problem with this variable across domains. There are several solutions to
this issue, one of which involves "protecting" our global variable using a
Mutex. However, we have specified that each domain manages its own <code>select</code>.</p>
<p>In general, a syscall is always local to a domain; it cannot be managed by
another domain that did not suspend it. In this sense, we can consider
allocating a <code>sleepers</code> for each domain. In OCaml, there is a way to consider
values that exist and are accessible to each domain, and these domains have
exclusivity over them: it's called <a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread Local Storage</a>.</p>
<p>So instead of having a global <code>sleepers</code>, we will use this API:</p>
<pre><code class="language-ocaml">let sleepers =
  let key = Stdlib.Domain.DLS.new_key Sleepers.create in
  fun () -&gt; Stdlib.Domain.DLS.get key

let sleep delay =
  let sleepers = sleepers () in
  let time = Unix.gettimeofday () +. delay in
  let syscall = Miou.syscall () in
  Sleepers.insert { time; syscall } sleepers;
  Miou.suspend syscall

let select ~block:_ _ =
  let sleepers = sleepers () in
  let ts = match Sleepers.find_min sleepers with
    | None -&gt; 0.0
    | Some { time; _ } -&gt;
      let value = time -. Unix.gettimeofday () in
      Float.max 0.0 value in
  Unix.sleepf ts;
  remove_and_signal_older sleepers []
</code></pre>
<p>We can now safely replace our <code>Miou.call_cc</code> with <code>Miou.call</code>. We know that each
task will have its own <code>sleepers</code>, and there will be no illegal access between
domains.</p>
<h2 id="cancellation-1"><a class="header" href="#cancellation-1">Cancellation</a></h2>
<p>There is one last point remaining: cancellation. Indeed, a task that has
suspended on a syscall can be canceled. We need to "clean up" our syscalls and
consider some of them unnecessary to observe. The <code>select</code> function has a final
argument corresponding to a list of canceled syscalls (with their unique
identifiers). When cancellation occurs, Miou attempts to collect all canceled
syscalls and then provides them to you so that you can clean up your variables
from these syscalls (in this case, our <code>sleepers</code>).</p>
<p>Another subtlety concerns inter-domain synchronization. Cancellation may require
synchronization between two domains, especially if we use <code>Miou.call</code> where the
promise exists in a different domain than the executing task. The problem is
that this synchronization may occur when one of the two domains performs
<code>Unix.sleepf</code>: in this case, we would need to wait for our domain to complete
its operation before continuing with cancellation. This is obviously not
feasible, especially if cancellation involves cleaning up a myriad of promises
and tasks across multiple domains (recall that <code>Miou.cancel</code> also cancels
children).</p>
<p>We have not mentioned it yet, but <code>events</code> has another function called
<code>interrupt</code>. This function precisely allows Miou to interrupt <code>select</code> because
the state of a promise has changed (and this change must be taken into account
in our syscall management).</p>
<p>So the question is: how do we interrupt <code>Unix.sleepf</code>? There are several
solutions, such as sending a signal, for example (and generating the
<code>EINTR</code><sup class="footnote-reference"><a href="#thread">2</a></sup> exception). However, we could just as well reuse <code>Unix.select</code>.
To remind you, this function can wait for a certain time (just like
<code>Unix.sleepf</code>) but can also be interrupted as soon as an event occurs (such as
the execution of <code>interrupt</code> by Miou). The idea is to create a file descriptor
that Miou can manipulate and that <code>Unix.select</code> can observe.</p>
<p>Once again, the idea is not to interrupt the entire domain. An interruption does
not necessarily mean that we want to wake up the domain because we know it is in
a state where it cannot handle cancellation—actually, we cannot know that. The
interruption just aims to unblock the domain only if it is performing a
<code>select</code>. Thus, it may happen that Miou attempts to interrupt multiple times
when it is unnecessary — because the domain in question is not operating on the
<code>select</code>. But that's okay; we can simply ignore these interruptions.</p>
<p>So, we have two things to do to manage cancellation:</p>
<ol>
<li>Clean up our sleepers from the syscalls given as arguments to our <code>select</code>
function.</li>
<li>Be able to interrupt our <code>select</code> using a file descriptor that Miou could
use.</li>
</ol>
<p>Let's start by cleaning up our syscalls. The problem with <code>Miou.Pqueue</code> is that
we cannot arbitrarily delete an element unless it is the smallest element.
Indeed, we could cancel a sleeper that is not necessarily the next in terms of
time. But we could <em>tag</em> our sleepers as canceled and simply ignore them when
we should signal them:</p>
<pre><code class="language-ocaml">type sleeper =
  { time : float
  ; syscall : Miou.syscall
  ; mutable cancelled : bool }

module Sleepers = Miou.Pqueue.Make (struct
  type t = sleeper

  let compare { time= a; _ } { time= b; _ } = Float.compare a b
  let dummy = { time= 0.0; syscall= Obj.magic (); cancelled= false }
end)

let sleepers =
  let key = Stdlib.Domain.DLS.new_key Sleepers.create in
  fun () -&gt; Stdlib.Domain.DLS.get key

let sleep delay =
  let sleepers = sleepers () in
  let time = Unix.gettimeofday () +. delay in
  let syscall = Miou.syscall () in
  Sleepers.insert { time; syscall; cancelled= false } sleepers;
  Miou.suspend syscall

let rec remove_and_signal_older sleepers acc =
  match Sleepers.find_min sleepers with
  | None -&gt; acc
  | Some { cancelled; _ } when cancelled -&gt;
    Sleepers.delete_min_exn sleepers;
    remove_and_signal_older sleepers acc
  | Some { time; syscall; _ } when in_the_past time -&gt;
    Sleepers.delete_min_exn sleepers;
    remove_and_signal_older sleepers (Miou.signal syscall :: acc)
  | Some _ -&gt; acc

let rec clean sleepers uids =
  let f ({ syscall; _ } as elt) =
    if List.exists ((=) (Miou.uid syscall)) uids
    then elt.cancelled &lt;- true in
  Sleepers.iter f sleepers

let rec minimum sleepers =
  match Sleepers.find_min sleepers with
  | None -&gt; None
  | Some { cancelled; _ } when cancelled -&gt;
    Sleepers.delete_min_exn sleepers;
    minimum sleepers
  | Some elt -&gt; Some elt

let select ~block:_ uids =
  let sleepers = sleepers () in
  clean sleepers uids;
  let ts = match minimum sleepers with
    | None -&gt; 0.0
    | Some { time; _ } -&gt;
      let value = time -. Unix.gettimeofday () in
      Float.max 0.0 value in
  Unix.sleepf ts;
  remove_and_signal_older sleepers []
</code></pre>
<p>Now, we need to implement our <code>interrupt</code> and modify our <code>select</code> accordingly so
that it can handle the interruption. As we explained, we will use <code>Unix.select</code>
to both wait for the necessary time (like <code>Unix.sleepf</code>) and observe a specific
event: whether we have been interrupted or not.</p>
<p>The interruption mechanism will be done using a file descriptor (because this is
what we can observe). We need to transmit a signal of some sort via our
<code>interrupt</code> function that <code>select</code> can handle. So we will create a <em>pipe</em> where
<code>interrupt</code> writes to it, and <code>select</code> reads from it as soon as it has bytes
available:</p>
<pre><code class="language-ocaml">let consume ic =
  let buf = Bytes.create 0x100 in
  ignore (Unix.read ic buf 0 (Bytes.length buf))

let select ic ~block:_ uids =
  let sleepers = sleepers () in
  clean sleepers uids;
  let ts = match minimum sleepers with
    | None -&gt; 0.0
    | Some { time; _ } -&gt;
      let value = time -. Unix.gettimeofday () in
      Float.max 0.0 value in
  match Unix.select [ ic ] [] [] ts with
  | [], _, _ -&gt; remove_and_signal_older sleepers []
  | ic :: _, _, _ -&gt;
    consume ic;
    remove_and_signal_older sleepers []

let buf = Bytes.make 1 '\000'

let events _ =
  let ic, oc = Unix.pipe () in
  let interrupt () = ignore (Unix.write oc buf 0 (Bytes.length buf)) in
  { Miou.select= select ic; interrupt }
</code></pre>
<p>And there you have it! We can now allow Miou to interrupt a <code>select</code> in the case
of cancellation. Interruption occurs quite frequently and is not limited to
cancellation. Here, we are mainly interested in unblocking our <code>Unix.select</code> so
that Miou can then handle its tasks immediately. It is also worth noting that we
don't consume our pipe interruption by interruption. There may be unnecessary
interruptions that we can ignore (hence reading 0x100 bytes instead of 1).</p>
<p>To demonstrate the validity of our implementation, we can try canceling a task
in parallel that would take too long:</p>
<pre><code class="language-ocaml">let () = Chat.run @@ fun () -&gt;
  let prm = Miou.call @@ fun () -&gt; Chat.sleep 10. in
  Miou.yield ();
  Miou.cancel prm
</code></pre>
<p>This code should not take 10 seconds but just the time it takes for
cancellation.</p>
<h2 id="blocking-indefinitely"><a class="header" href="#blocking-indefinitely">Blocking indefinitely</a></h2>
<p>As you can imagine, we have still omitted some details in our tutorial.
Particularly, the <code>block</code> option. This option signals from Miou that there are
no tasks left to handle, and only syscalls can unblock your application. This is
typically what we expect from a system and network application: fundamentally
waiting for system events as a top priority.</p>
<p>In this regard, if <code>block:true</code>, we can afford to wait indefinitely (while still
considering possible interruptions) without handing control back to Miou until
there is an event. To do this, <code>Unix.select</code> can have <code>-1.0</code> as its last
argument. However, in our example, this is not very relevant. But for our <code>echo</code>
server, it's crucial that it does nothing but wait for system events. In this
regard, we recommend reading the implementation of <code>Miou_unix</code>, which closely
resembles what we have just done and handles the <code>block</code> option.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>You've finally completed this little tutorial, which demonstrates what is
arguably the most challenging part of Miou. It should be noted that we have
mentioned other possible solutions in our interaction with the system here and
there:</p>
<ul>
<li>starting with <code>epoll()</code></li>
<li>mentioning interruption mechanisms other than our <code>Unix.pipe</code></li>
<li>explaining a completely different design with <code>Stdlib.Thread</code> that could be
more efficient</li>
</ul>
<p>In addition to these, there are subtle differences between systems (even Unix),
and we realize that standardizing and homogenizing such a problem is a difficult
task. What is most important to take away from this tutorial is Miou's ability
to allow you to re-appropriate what is, for us, essential in the development of
a system and network application: interactions with the system.</p>
<p>We could claim (and have the audacity to) offer solutions that would cover 90%
of use cases in the development of such applications, but in our ambition to
create unikernels as a service, we definitely fall into the margin (the
remaining 10%). In this regard, we offer perhaps something that may be
rudimentary but accessible and usable for truly all use cases.</p>
<p>Finally, this book is not finished. As mentioned in the previous chapter, we
still need to cover Mutexes and Conditions. To do this, we will reuse our <code>echo</code>
server and improve it!</p>
<div class="footnote-definition" id="proof"><sup class="footnote-definition-label">1</sup>
<p>It is worth noting that the <code>Miou.Pqueue</code> module comes from an
extraction of an implementation of a proven priority queue using <a href="https://www.why3.org/">Why3</a>
(see the <a href="https://github.com/ocaml-gospel/vocal">vocal</a> project).</p>
</div>
<div class="footnote-definition" id="thread"><sup class="footnote-definition-label">2</sup>
<p>Another solution, which would be more challenging to implement but
more efficient, would be to use <code>Stdlib.Thread</code> to observe events. This
observation would occur concurrently with our domain and transmit signals via a
shared queue with our <code>select</code>. In this case, <code>select</code> would no longer be
blocking at all, and we would no longer need to implement an <code>interrupt</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditions--mutexes"><a class="header" href="#conditions--mutexes">Conditions &amp; Mutexes</a></h1>
<p>When it came to implementing our small scheduler and interacting with the
system, the main challenge was to address the issue of suspending a function so
that it could run in the background. However, it's not just syscalls that can
suspend/block the execution of a function. There are also Mutexes and
Conditions.</p>
<p>The real challenge of a scheduler is to be able to suspend functions without
involving the system: in other words, to manage all suspensions. For novices,
Mutexes and Conditions allow you to block and unblock the execution of a
function (possibly based on a predicate).</p>
<p>The usefulness of such mechanisms lies in synchronizing tasks with each other.
Whether they are in concurrency and/or in parallel, it is difficult, if not
impossible, to know which task will execute before the others. However, we
sometimes (and often) want to share information between these tasks. Miou only
allows one type of information transfer between tasks: from children to their
direct parents.</p>
<p>In all other cases (for example, between two tasks with no direct parent-child
relationship and executing in parallel), we need to consider how to transfer
this information correctly (meaning that this transfer would work regardless of
the execution order of our tasks from both Miou's perspective — for
<code>Miou.call_cc</code> — and the system's perspective — for <code>Miou.call</code>). It is in these
cases that Mutexes and Conditions can be useful.</p>
<h2 id="mutexes"><a class="header" href="#mutexes">Mutexes</a></h2>
<p>Mutexes allow obtaining exclusive access to manipulate information compared to
other tasks. This means that we can manipulate a global resource, available to
all tasks, securely using mutexes. To illustrate this example, let's revisit our
<code>echo</code> server where we want to display incoming connections as logs:</p>
<pre><code class="language-ocaml">let pp_sockaddr ppf = function
  | Unix.ADDR_UNIX v -&gt; Format.pp_print_string ppf v
  | Unix.ADDR_INET (inet_addr, port) -&gt;
    Format.fprintf ppf "%s:%d" (Unix.string_of_inet_addr inet_addr) port

let server () =
  let socket = Miou_unix.Ownership.tcpv4 () in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Miou_unix.Ownership.bind_and_listen socket sockaddr;
  let orphans = Miou.orphans () in
  while true do
    clean_up orphans;
    let client, sockaddr = Miou_unix.Ownership.accept socket in
    Format.printf "new client: %a\n%!" pp_sockaddr sockaddr;
    ignore (Miou.call_cc
      ~give:[ Miou_unix.Ownership.resource clientr 
      ~orphans (fun () -&gt; echo client))
  done;
  Miou_unix.Ownership.close socket
</code></pre>
<p>It <strong>may</strong> happen (and this is the difficulty of parallel programming) that an
exception occurs seemingly out of nowhere if you run this code:</p>
<pre><code class="language-ocaml">Fatal error: exception Stdlib.Queue.Empty
</code></pre>
<p>The real issue is that the <code>Format</code> module uses an internal queue to properly
indent your output (especially according to the <a href="https://v2.ocaml.org/api/Format.html#boxes">boxes</a>). In our case, this
queue ends up being manipulated by all our domains, and, as mentioned in the
<a href="https://v2.ocaml.org/api/Queue.html">Stdlib.Queue</a> documentation, the module is <strong>not</strong> thread-safe: the
documentation explicitly mentions the use of a mutex<sup class="footnote-reference"><a href="#queue">1</a></sup>.</p>
<p>So, we need to protect our output between domains. To do this, a simple mutex is
necessary:</p>
<pre><code class="language-ocaml">let mutex_out = Miou.Mutex.create ()

let printf fmt =
  let finally () = Miou.Mutex.unlock mutex_out in
  Miou.Mutex.lock mutex_out;
  Fun.protect ~finally @@ fun () -&gt;
  Format.printf fmt
</code></pre>
<p>This way, we ensure that only one task executes our <code>Format.printf</code> and that the
others must wait for the first one to finish. We say it has exclusive access to
the resource.</p>
<h2 id="conditions"><a class="header" href="#conditions">Conditions</a></h2>
<p>A major issue with our <code>echo</code> server is its termination. Currently, we are
unable to terminate our server properly due to the infinite loop. However, we
could handle a system signal that instructs all our domains to terminate
gracefully. Since our main loop only accepts connections, we could implement a
function <code>accept_or_die</code> that, upon receiving a signal such as <code>SIGINT</code>,
initiates the process to terminate our domains.</p>
<p>Once again, a global resource comes into play — the signal sent by the system.
We need to return a <code> `Die</code> value instead of waiting for a new connection. The
purpose of a condition is to wait until a predicate (obtained using a global
resource) becomes true. In the case of our <code>echo</code> server, if we receive a
<code>SIGINT</code> signal, we return <code> `Die</code>; otherwise, we continue waiting for a new
connection.</p>
<pre><code class="language-ocaml">let condition = Miou.Condition.create ()
let mutex_sigint = Miou.Mutex.create ()

let accept_or_die fd =
  let accept () = `Accept (Miou_unix.Ownership.accept fd) in
  let or_die () =
    Miou.Mutex.protect mutex_sigint @@ fun () -&gt;
    Miou.Condition.wait condition mutex_sigint;
    `Die in
  Miou.await_first [ Miou.call_cc accept; Miou.call_cc or_die ]
  |&gt; function Ok value -&gt; value | Error exn -&gt; raise exn

let server () =
  let socket = Miou_unix.Ownership.tcpv4 () in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Miou_unix.Ownership.bind_and_listen socket sockaddr;
  let rec go orphans =
    clean_up orphans;
    match accept_or_die socket with
    | `Die -&gt; ()
    | `Accept (fd', sockaddr) -&gt;
      printf "new client: %a\n%!" pp_sockaddr sockaddr;
      ignore (Miou.call_cc
        ~give:[ Miou_unix.Ownership.resource client ]
        ~orphans (fun () -&gt; echo client));
      go orphans in
  go (Miou.orphans ())
</code></pre>
<p>We then need to "catch" the <code>SIGINT</code> signal. Signals are special in that they
can execute a task outside of Miou. However, if these tasks have side effects,
they won't be managed. Thus, Miou offers a way to attach functions to signals
using <code>Miou.set_signal</code>:</p>
<pre><code class="language-ocaml">let stop _signal =
  Miou.Mutex.protect mutex_sigint @@ fun () -&gt;
  Miou.Condition.broadcast condition

let () = Miou_unix.run @@ fun () -&gt;
  Miou.set_signal Sys.sigint (Sys.Signal_handle stop);
  let domains = Stdlib.Domain.recommended_domain_count () - 1 in
  let domains = List.init domains (Fun.const ()) in
  let prm = Miou.call_cc server in
  Miou.await prm :: Miou.parallel server domains
  |&gt; List.iter @@ function
  | Ok () -&gt; ()
  | Error exn -&gt; raise exn
</code></pre>
<p>This simply signals all places where our condition is waiting. Consequently, all
our domains are signaled to return <code> `Die</code> instead of continuing to wait for a
new connection.</p>
<h3 id="ownership-sub-tasks-and-finalisers"><a class="header" href="#ownership-sub-tasks-and-finalisers">Ownership, sub-tasks and finalisers</a></h3>
<p>If we try this code, it may not work, and Miou might complain with the
<code>Not_owner</code> exception. This is because our <code>accept</code> task does not own the
file-descritptor; we need to pass it the resource via the <code>give</code> parameter.</p>
<p>It's worth noting that this ownership is exclusive. Once we've performed
<code>Miou_unix.Ownership.accept</code>, we need to:</p>
<ol>
<li>transfer the file-descritptor back to the parent (so it can transfer it to
the next <code>accept</code>).</li>
<li>transfer the new file-descriptor to the parent that was created in our
<code>accept</code> task so that it can transfer it to our <code>echo</code> task.</li>
</ol>
<p>The importance of finalizers in this situation should also be noted. Indeed,
<code>await_first</code> will wait for one of the two tasks. If our condition unblocks and
returns <code> `Die</code>, <code>await_first</code> will then cancel our <code>accept</code> task: we then
finish it in an abnormal situation where our finalizers will be called on our
file-descriptors. In other words, except for the active clients, all our
resources have been properly released by Miou, and we no longer need to take
care of them during the termination of our program.</p>
<p>Finally, even after these minor fixes, Miou may still return
<code>Still_has_children</code>. Indeed, receiving a signal does not mean that we have
finished all our children (we just cleaned up a few). However, we do know that:</p>
<ul>
<li>we will not have any new children.</li>
<li>our <code>echo</code> task should terminate smoothly despite our signal.</li>
</ul>
<p>So we need to <code>await</code> all our remaining children:</p>
<pre><code class="language-ocaml">let rec terminate orphans =
  match Miou.care orphans with
  | None -&gt; ()
  | Some None -&gt; Miou.yield (); terminate orphans
  | Some (Some prm) -&gt;
    match Miou.await prm with
    | Ok () -&gt; ()
    | Error exn -&gt; raise exn
</code></pre>
<h2 id="the-final-version-of-echo"><a class="header" href="#the-final-version-of-echo">The final version of <code>echo</code></a></h2>
<p>If we take all our previous comments into account, here is the final version of
our <code>echo</code> server:</p>
<pre><code class="language-ocaml">let condition = Miou.Condition.create ()
let mutex_sigint = Miou.Mutex.create ()
let mutex_out = Miou.Mutex.create ()

let printf fmt =
  let finally () = Miou.Mutex.unlock mutex_out in
  Miou.Mutex.lock mutex_out;
  Fun.protect ~finally @@ fun () -&gt;
  Format.printf fmt

let rec echo client =
  let buf = Bytes.create 0x100 in
  let len = Miou_unix.Ownership.read client buf 0 (Bytes.length buf) in
  if len = 0 then Miou_unix.Ownership.close client
  else
    let str = Bytes.sub_string buf 0 len in
    let _ = Miou_unix.Ownership.write client str 0 len in echo client

let accept_or_die fd =
  let accept () =
    let fd', sockaddr = Miou_unix.Ownership.accept fd in
    Miou.Ownership.transfer (Miou_unix.Ownership.resource fd');
    Miou.Ownership.transfer (Miou_unix.Ownership.resource fd);
    `Accept (fd', sockaddr) in
  let or_die () =
    Miou.Mutex.protect mutex_sigint @@ fun () -&gt;
    Miou.Condition.wait condition mutex_sigint;
    `Die in
  let give = [ Miou_unix.Ownership.resource fd ] in
  Miou.await_first [ Miou.call_cc ~give accept; Miou.call_cc or_die ]
  |&gt; function Ok value -&gt; value | Error exn -&gt; raise exn

let pp_sockaddr ppf = function
  | Unix.ADDR_UNIX v -&gt; Format.pp_print_string ppf v
  | Unix.ADDR_INET (inet_addr, port) -&gt;
    Format.fprintf ppf "%s:%d" (Unix.string_of_inet_addr inet_addr) port

let clean_up orphans = match Miou.care orphans with
  | None | Some None -&gt; ()
  | Some (Some prm) -&gt; match Miou.await prm with
    | Ok () -&gt; ()
    | Error exn -&gt; raise exn

let rec terminate orphans =
  match Miou.care orphans with
  | None -&gt; ()
  | Some None -&gt; Miou.yield (); terminate orphans
  | Some (Some prm) -&gt;
    match Miou.await prm with
    | Ok () -&gt; ()
    | Error exn -&gt; raise exn

let server () =
  let socket = Miou_unix.Ownership.tcpv4 () in
  let sockaddr = Unix.ADDR_INET (Unix.inet_addr_loopback, 3000) in
  Miou_unix.Ownership.bind_and_listen socket sockaddr;
  let rec go orphans =
    clean_up orphans;
    match accept_or_die socket with
    | `Die -&gt; terminate orphans
    | `Accept (client, sockaddr) -&gt;
      printf "new client: %a\n%!" pp_sockaddr sockaddr;
      ignore (Miou.call_cc
        ~give:[ Miou_unix.Ownership.resource client ]
        ~orphans (fun () -&gt; echo client));
      go orphans in
  go (Miou.orphans ())

let stop _signal =
  Miou.Mutex.protect mutex_sigint @@ fun () -&gt;
  Miou.Condition.broadcast condition

let () = Miou_unix.run @@ fun () -&gt;
  Miou.set_signal Sys.sigint (Sys.Signal_handle stop);
  let domains = Stdlib.Domain.recommended_domain_count () - 1 in
  let domains = List.init domains (Fun.const ()) in
  let prm = Miou.call_cc server in
  Miou.await prm :: Miou.parallel server domains
  |&gt; List.iter @@ function
  | Ok () -&gt; ()
  | Error exn -&gt; raise exn
</code></pre>
<p>You can compile it directly with <code>ocamlfind</code>, run it and, above all, test its
load with <code>parallel</code>:</p>
<pre><code class="language-shell">$ ocamlfind opt -linkpkg -package miou,miou.unix main.ml
$ ./a.out &amp;
$ cat &gt;echo.sh&lt;&lt;EOF
#!/bin/bash

send() {
  echo "Hello World" | netcat -q0 localhost 3000
}

export -f send

while true; do
  parallel send ::: $(seq 100)
done
EOF
$ chmod +x echo.sh
$ ./echo.sh
</code></pre>
<p>Our final command launches a myriad of clients, with 100 of them executing
simultaneously. We can observe that all our domains are at work, and there are
no conflicts on the console thanks to our mutex. Finally, to appreciate all our
work, a <code>SIGINT</code> (with Ctrl+C) will terminate our server correctly and release
all our file descriptors!</p>
<p>This little project broadly demonstrates what is possible with Miou and the
insights that emerged during its development, particularly regarding system
resources and I/O. We hope this tutorial has sparked your interest in using Miou
in your applications. For the more adventurous, you can read our manifesto,
which explains, in a more social than technical manner, the benefits of Miou.</p>
<div class="footnote-definition" id="queue"><sup class="footnote-definition-label">1</sup>
<p>It is worth noting that Miou offers a thread-safe queue: <code>Miou.Queue</code>.
We use it internally for various purposes, particularly in inter-domain
synchronization. However, it is essential to recognize that <code>Miou.Queue</code> may
reveal other issues such as inter-domain contention.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifesto"><a class="header" href="#manifesto">Manifesto</a></h1>
<p>Ce petit manifeste permet d'expliciter nos ambitions par rapport à Miou et notre
coopérative. En effet, au delà des questions techniques que peuvent soulever un
scheduler, il y a aussi des réalités sociales à prendre en compte qui argumentent
l'existence de Miou dans un écosystème qui peut se retrouver fragmenter sur ces
questions. Il ne s'agit pas de partager notre avis sur ce qu'on peut retrouver
entant que projet concurrent à Miou ni prêter des propos et des actes dont vous
ne pouvez être que le seul juge, il s'agit de dire ce qu'est Miou à nos yeux.</p>
<p>This small manifesto aims to clarify our ambitions regarding Miou and our
cooperative. Beyond the technical questions raised by a scheduler, there are
also social realities to consider that justify Miou's existence in an ecosystem
that can become fragmented on these issues. It is not about sharing our opinion
on what might be found as a competing project to Miou or attributing statements
and actions of which you alone can be the judge; it is about expressing what
Miou means to us.</p>
<h2 id="protocols-services--miou"><a class="header" href="#protocols-services--miou">Protocols, services &amp; Miou</a></h2>
<p>For several years, we have been endeavoring to produce services in OCaml in the
form of unikernels, as evidenced by this website. In pursuing this goal, the
implementation of protocols and services in OCaml naturally comes into play
within our cooperative. It is worth noting that we have implemented many
protocols to date and intend to continue in this direction.</p>
<p>What we have learned over these years is the logical and indeed necessary
separation between the protocol and the scheduler. Even if the sole application
domain of implementing a protocol is I/O, we will continue to produce libraries
that do <strong>not</strong> depend on Miou.</p>
<p>In this regard, we encourage our users to follow the same path. As mentioned in
this tutorial, the scheduler is the final frontier between your application and
reality: the aim is to push this question as far back as possible to ultimately
make the best choice on which scheduler to use.</p>
<p>Furthermore, we will not impose the use of Miou in the majority of the software
we develop and maintain. However, we still have a <em>slight</em> preference for it.</p>
<h2 id="miou-extension"><a class="header" href="#miou-extension">Miou Extension</a></h2>
<p>For some, Miou is very, even too, minimal. It offers the bare minimum for
developing system and network applications, and it can be tedious to reconsider
(and reimplement) basic building blocks in the design of an application that
Miou does not provide.</p>
<p>Once again, we do not shy away from our goal of integrating Miou into our
unikernels, where this choice to restrict the application domain of our library
becomes a necessity. In this regard, Miou will remain small.</p>
<p>However, this choice can be understood (and we hope our users can understand it
this way) as our humility in not seeking to homogenize and/or standardize an
ecosystem in which we believe you can find your place: a place that may involve
extending or even rebuilding Miou. Thus, Miou's goal is not to be widely used.</p>
<p>All this is to inform our future users that extending Miou to facilitate
application development can be done as third-party libraries but would not be
integrated into Miou.</p>
<h2 id="collective-work"><a class="header" href="#collective-work">Collective Work</a></h2>
<p>At several points in our tutorial, we mentioned that we are not necessarily
omniscient about all possible techniques, for example, regarding synchronization
between multiple tasks. In reality, Miou raises many challenges that can be
daunting in terms of our skills and resources (we are only a small cooperative).</p>
<p>But we believe (and we hope to demonstrate publicly on a daily basis) in
collective work and the contribution of our users to evolve Miou in a direction
that can satisfy everyone. This collective work can be long, sometimes thankless
(and we are the first to acknowledge it), but we would be delighted if Miou were
the synthesis of a community rather than just a few people with very (too)
strong opinions.</p>
<p>Moreover, this is already the case. Miou draws heavily from its <em>"competitors"</em>
and builds upon the outstanding work of individuals who have pondered the same
questions as us regarding scheduler implementation. It is a task that can be
lengthy (both in assimilation and implementation) but can correspond, at least,
to our cooperative structure.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>Thus, this little manifesto concludes with thanks to all the individuals who,
directly or indirectly, have contributed to the development of Miou as well as
to the <a href="https://robur.coop/">Robur</a> cooperative, which has enabled the development of such a
library. Hoping that our opinions and vision for the future of Miou resonate
with you, we will be delighted, even if only to assist you in reclaiming the
means of communication.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
